diff --git a/lib/Transforms/Scalar/NewGVN.cpp b/lib/Transforms/Scalar/NewGVN.cpp
index 5aa8be6..7574deb 100644
--- a/lib/Transforms/Scalar/NewGVN.cpp
+++ b/lib/Transforms/Scalar/NewGVN.cpp
@@ -72,23 +72,9 @@ using namespace llvm::GVNExpression;
 
 STATISTIC(NumGVNInstrDeleted, "Number of instructions deleted");
 STATISTIC(NumGVNBlocksDeleted, "Number of blocks deleted");
-STATISTIC(NumNewGVNPRE, "Number of instructions PRE'd");
-// STATISTIC(NumNewGVNBlocks, "Number of blocks merged");
-// STATISTIC(NumNewGVNSimpl, "Number of instructions simplified");
-STATISTIC(NumGVNEqProp, "Number of equalities propagated");
-STATISTIC(NumPRELoad, "Number of loads PRE'd");
 STATISTIC(NumGVNOpsSimplified, "Number of Expressions simplified");
 STATISTIC(NumGVNPhisAllSame, "Number of PHIs whos arguments are all the same");
 
-static cl::opt<bool> EnablePRE("enable-pre2", cl::init(true), cl::Hidden);
-static cl::opt<bool> EnableLoadPRE("enable-load-pre2", cl::init(true));
-
-// Maximum allowed recursion depth.
-static cl::opt<uint32_t>
-    MaxRecurseDepth("max-recurse-depth2", cl::Hidden, cl::init(1000),
-                    cl::ZeroOrMore,
-                    cl::desc("Max recurse depth (default = 1000)"));
-
 //===----------------------------------------------------------------------===//
 //                                GVN Pass
 //===----------------------------------------------------------------------===//
@@ -124,11 +110,6 @@ struct CongruenceClass {
   const Expression *DefiningExpr;
   // Actual members of this class.  These are the things the same everywhere
   MemberSet Members;
-  // Coercible members of this class. These are loads where we can pull the
-  // value out of a store. This means they need special processing during
-  // elimination to do this, but they are otherwise the same as members,
-  // in particular, we can eliminate one in favor of a dominating one.
-  MemberSet CoercibleMembers;
 
   // True if this class has no members left.  This is mainly used for assertion
   // purposes, and for skipping empty classes.
@@ -140,68 +121,7 @@ struct CongruenceClass {
       : ID(ID), RepLeader(Leader), DefiningExpr(E), Dead(false) {}
 };
 
-struct EdgePredicate {
-  // First OP Second == Val
-  Value *First;
-  CmpInst::Predicate Op;
-  Value *Second;
-  Value *Val;
-};
-
-bool operator==(const EdgePredicate &LHS, const EdgePredicate &RHS) {
-  return LHS.First == RHS.First && LHS.Op == RHS.Op &&
-         LHS.Second == RHS.Second && LHS.Val == RHS.Val;
-}
-
-template <> struct DenseMapInfo<EdgePredicate> {
-  typedef DenseMapInfo<const Value *> DMI;
-  static inline const EdgePredicate getEmptyKey() {
-    return {nullptr, CmpInst::BAD_ICMP_PREDICATE, nullptr, nullptr};
-  }
-  static inline const EdgePredicate getTombstoneKey() {
-    return {nullptr, CmpInst::BAD_FCMP_PREDICATE, nullptr, nullptr};
-  }
-  static unsigned getHashValue(const EdgePredicate &V) {
-
-    return hash_combine(DMI::getHashValue(V.First),
-                        static_cast<unsigned long>(V.Op),
-                        DMI::getHashValue(V.Second), DMI::getHashValue(V.Val));
-  }
-  static bool isEqual(const EdgePredicate &First, const EdgePredicate &Second) {
-    return First == Second;
-  }
-};
-
-bool operator!=(const EdgePredicate &LHS, const EdgePredicate &RHS) {
-  return !(LHS == RHS);
-}
-
-template <> struct DenseMapInfo<const Expression *> {
-  static inline const Expression *getEmptyKey() {
-    uintptr_t Val = static_cast<uintptr_t>(-1);
-    Val <<= PointerLikeTypeTraits<const Expression *>::NumLowBitsAvailable;
-    return reinterpret_cast<const Expression *>(Val);
-  }
-  static inline const Expression *getTombstoneKey() {
-    uintptr_t Val = static_cast<uintptr_t>(-2);
-    Val <<= PointerLikeTypeTraits<const Expression *>::NumLowBitsAvailable;
-    return reinterpret_cast<const Expression *>(Val);
-  }
-  static unsigned getHashValue(const Expression *V) {
-    return static_cast<unsigned>(V->getHashValue());
-  }
-  static bool isEqual(const Expression *LHS, const Expression *RHS) {
-    if (LHS == RHS)
-      return true;
-    if (LHS == getTombstoneKey() || RHS == getTombstoneKey() ||
-        LHS == getEmptyKey() || RHS == getEmptyKey())
-      return false;
-    return *LHS == *RHS;
-  }
-};
-
 class NewGVN : public FunctionPass {
-  MemoryDependenceResults *MD;
   DominatorTree *DT;
   const DataLayout *DL;
   const TargetLibraryInfo *TLI;
@@ -221,31 +141,32 @@ class NewGVN : public FunctionPass {
   DenseMap<Value *, CongruenceClass *> ValueToClass;
   DenseMap<Value *, const Expression *> ValueToExpression;
 
-  struct expression_equal_to {
-    bool operator()(const Expression *A, const Expression *B) const {
-      if (A == B)
+  struct ComparingExpressionInfo : public DenseMapInfo<const Expression *> {
+    static unsigned getHashValue(const Expression *V) {
+      return static_cast<unsigned>(V->getHashValue());
+    }
+    static bool isEqual(const Expression *LHS, const Expression *RHS) {
+      if (LHS == RHS)
         return true;
-      return *A == *B;
+      if (LHS == getTombstoneKey() || RHS == getTombstoneKey() ||
+          LHS == getEmptyKey() || RHS == getEmptyKey())
+        return false;
+      return *LHS == *RHS;
     }
   };
-  struct hash_expression {
-    size_t operator()(const Expression *A) const { return A->getHashValue(); }
-  };
 
   // Expression to class mapping
-  typedef DenseMap<const Expression *, CongruenceClass *> ExpressionClassMap;
+  typedef DenseMap<const Expression *, CongruenceClass *,
+                   ComparingExpressionInfo>
+      ExpressionClassMap;
   ExpressionClassMap ExpressionToClass;
 
   // Which values have changed as a result of leader changes
   SmallPtrSet<Value *, 8> ChangedValues;
 
   // Reachability info
-  typedef BasicBlockEdge BlockEdge;
-  DenseMap<BlockEdge, DenseSet<EdgePredicate>> EdgePredicates;
-  DenseSet<BlockEdge> ReachableEdges;
+  DenseSet<std::pair<BasicBlock *, BasicBlock *>> ReachableEdges;
   SmallPtrSet<const BasicBlock *, 8> ReachableBlocks;
-  // Map from a block to which single incoming edge is reachable, if any.
-  SmallDenseMap<const BasicBlock *, const BasicBlock *> SingleReachableIncoming;
   // This is a bitvector because, on larger functions, we may have
   // thousands of touched instructions at once (entire blocks,
   // instructions with hundreds of uses, etc).  Even with optimization
@@ -256,9 +177,6 @@ class NewGVN : public FunctionPass {
   // individual and ranges, as well as "find next element" This
   // enables us to use it as a worklist with essentially 0 cost.
   BitVector TouchedInstructions;
-  // We mark which instructions were affected by an equivalence, so we only have
-  // to revisit those instructions when an edge change occurs
-  BitVector InvolvedInEquivalence;
   DenseMap<const BasicBlock *, std::pair<unsigned, unsigned>> BlockInstRange;
   DenseMap<const DomTreeNode *, std::pair<unsigned, unsigned>>
       DominatedInstRange;
@@ -272,28 +190,17 @@ class NewGVN : public FunctionPass {
 
   // Deletion info
   SmallPtrSet<Instruction *, 8> InstructionsToErase;
-  // This is a mapping from Load to (offset into source, coercion source)
-  DenseMap<const Value *, std::pair<unsigned, Value *>> CoercionInfo;
-  // This is a mapping for loads that got widened, to the new load. This ensures
-  // we coerce from the new widened load, instead of the old one. Otherwise, we
-  // may try to widen the same old load multiple times.
-  DenseMap<const Value *, Value *> CoercionForwarding;
-
-  // This is used by PRE to forward values when they get replaced
-  // Because we don't update the expressions, ValueToExpression will point to
-  // expressions which have the old arguments in them
-  DenseMap<const Value *, Value *> PREValueForwarding;
-  PredIteratorCache PredCache;
 
 public:
   static char ID; // Pass identification, replacement for typeid
-  explicit NewGVN() : FunctionPass(ID), MD(nullptr) {
+  explicit NewGVN() : FunctionPass(ID) {
     initializeNewGVNPass(*PassRegistry::getPassRegistry());
   }
 
   bool runOnFunction(Function &F) override;
   bool runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
-              TargetLibraryInfo *TLI, AliasAnalysis *AA, MemorySSA *MSSA);
+              TargetLibraryInfo *TLI, AliasAnalysis *AA,
+              MemorySSA *MSSA);
 
 private:
   // This transformation requires dominator postdominator info
@@ -315,16 +222,13 @@ private:
   bool setBasicExpressionInfo(Instruction *, BasicExpression *,
                               const BasicBlock *);
   PHIExpression *createPHIExpression(Instruction *);
-  const VariableExpression *createVariableExpression(Value *, bool);
-  const ConstantExpression *createConstantExpression(Constant *, bool);
+  const VariableExpression *createVariableExpression(Value *);
+  const ConstantExpression *createConstantExpression(Constant *);
   const Expression *createVariableOrConstant(Value *V, const BasicBlock *B);
   const StoreExpression *createStoreExpression(StoreInst *, MemoryAccess *,
                                                const BasicBlock *);
   LoadExpression *createLoadExpression(Type *, Value *, LoadInst *,
                                        MemoryAccess *, const BasicBlock *);
-  const CoercibleLoadExpression *
-  createCoercibleLoadExpression(Type *, Value *, LoadInst *, MemoryAccess *,
-                                unsigned, Value *, const BasicBlock *);
 
   const CallExpression *createCallExpression(CallInst *, MemoryAccess *,
                                              const BasicBlock *);
@@ -351,12 +255,6 @@ private:
   const Expression *checkSimplificationResults(Expression *, Instruction *,
                                                Value *);
   const Expression *performSymbolicEvaluation(Value *, const BasicBlock *);
-  const Expression *performSymbolicLoadCoercionFromPhi(Type *, Value *,
-                                                       LoadInst *, MemoryPhi *,
-                                                       const BasicBlock *);
-  const Expression *performSymbolicLoadCoercion(Type *, Value *, LoadInst *,
-                                                Instruction *, MemoryAccess *,
-                                                const BasicBlock *);
   const Expression *performSymbolicLoadEvaluation(Instruction *,
                                                   const BasicBlock *);
   const Expression *performSymbolicStoreEvaluation(Instruction *,
@@ -367,198 +265,37 @@ private:
                                                  const BasicBlock *);
   const Expression *performSymbolicAggrValueEvaluation(Instruction *,
                                                        const BasicBlock *);
-  int analyzeLoadFromClobberingStore(Type *, Value *, StoreInst *);
-  int analyzeLoadFromClobberingLoad(Type *, Value *, LoadInst *);
-  int analyzeLoadFromClobberingMemInst(Type *, Value *, MemIntrinsic *);
-  int analyzeLoadFromClobberingWrite(Type *, Value *, Value *, uint64_t);
+
   // Congruence finding
   // Templated to allow them to work both on BB's and BB-edges
   template <class T>
-  std::pair<Value *, bool> lookupOperandLeader(Value *, const T &) const;
-
+  Value *lookupOperandLeader(Value *, const User *, const T &) const;
   void performCongruenceFinding(Value *, const Expression *);
-  // Predicate and reachability handling
+
+  // Reachability handling
   void updateReachableEdge(BasicBlock *, BasicBlock *);
   void processOutgoingEdges(TerminatorInst *, BasicBlock *);
-  void propagateChangeInEdge(BasicBlock *);
   bool isOnlyReachableViaThisEdge(const BasicBlockEdge &);
-
   Value *findConditionEquivalence(Value *, BasicBlock *) const;
-  const std::pair<unsigned, unsigned>
-  calculateDominatedInstRange(const DomTreeNode *);
-  Value *inferValueAtBlock(Value *V, const BasicBlock *B) const;
-  Value *inferValueOfPredicate(Value *V, const BasicBlock *B) const;
+
   // Elimination
   struct ValueDFS;
   void convertDenseToDFSOrdered(CongruenceClass::MemberSet &,
-                                std::vector<ValueDFS> &, bool);
+                                std::vector<ValueDFS> &);
 
   bool eliminateInstructions(Function &);
   void replaceInstruction(Instruction *, Value *);
   void markInstructionForDeletion(Instruction *);
   void deleteInstructionsInBlock(BasicBlock *);
-  bool canCoerceMustAliasedValueToLoad(Value *, Type *);
-  Value *coerceAvailableValueToLoadType(Value *, Type *, Instruction *);
-  Value *getStoreValueForLoad(Value *, unsigned, Type *, Instruction *);
-  Value *getLoadValueForLoad(LoadInst *, unsigned, Type *, Instruction *);
-  Value *getMemInstValueForLoad(MemIntrinsic *, unsigned, Type *, Instruction *,
-                                bool NoNewInst = false);
-  Value *coerceLoad(Value *);
+
   // New instruction creation
   void handleNewInstruction(Instruction *){};
   void markUsersTouched(Value *);
+
   // Utilities
   void cleanupTables();
   std::pair<unsigned, unsigned> assignDFSNumbers(BasicBlock *, unsigned);
-
-  /// Represents a particular available value that we know how to materialize.
-  /// Materialization of an AvailableValue never fails.  An AvailableValue is
-  /// implicitly associated with a rematerialization point which is the
-  /// location of the instruction from which it was formed.
-  struct AvailableValue {
-    enum ValType {
-      SimpleVal, // A simple offsetted value that is accessed.
-      LoadVal,   // A value produced by a load.
-      MemIntrin, // A memory intrinsic which is loaded from.
-      UndefVal   // A UndefValue representing a value from dead block (which
-                 // is not yet physically removed from the CFG).
-    };
-
-    /// V - The value that is live out of the block.
-    PointerIntPair<Value *, 2, ValType> Val;
-
-    /// Offset - The byte offset in Val that is interesting for the load query.
-    unsigned Offset;
-
-    static AvailableValue get(Value *V, unsigned Offset = 0) {
-      AvailableValue Res;
-      Res.Val.setPointer(V);
-      Res.Val.setInt(SimpleVal);
-      Res.Offset = Offset;
-      return Res;
-    }
-
-    static AvailableValue getMI(MemIntrinsic *MI, unsigned Offset = 0) {
-      AvailableValue Res;
-      Res.Val.setPointer(MI);
-      Res.Val.setInt(MemIntrin);
-      Res.Offset = Offset;
-      return Res;
-    }
-
-    static AvailableValue getLoad(LoadInst *LI, unsigned Offset = 0) {
-      AvailableValue Res;
-      Res.Val.setPointer(LI);
-      Res.Val.setInt(LoadVal);
-      Res.Offset = Offset;
-      return Res;
-    }
-
-    static AvailableValue getUndef() {
-      AvailableValue Res;
-      Res.Val.setPointer(nullptr);
-      Res.Val.setInt(UndefVal);
-      Res.Offset = 0;
-      return Res;
-    }
-
-    bool isSimpleValue() const { return Val.getInt() == SimpleVal; }
-    bool isCoercedLoadValue() const { return Val.getInt() == LoadVal; }
-    bool isMemIntrinValue() const { return Val.getInt() == MemIntrin; }
-    bool isUndefValue() const { return Val.getInt() == UndefVal; }
-
-    Value *getSimpleValue() const {
-      assert(isSimpleValue() && "Wrong accessor");
-      return Val.getPointer();
-    }
-
-    LoadInst *getCoercedLoadValue() const {
-      assert(isCoercedLoadValue() && "Wrong accessor");
-      return cast<LoadInst>(Val.getPointer());
-    }
-
-    MemIntrinsic *getMemIntrinValue() const {
-      assert(isMemIntrinValue() && "Wrong accessor");
-      return cast<MemIntrinsic>(Val.getPointer());
-    }
-
-    /// Emit code at the specified insertion point to adjust the value defined
-    /// here to the specified type. This handles various coercion cases.
-    Value *MaterializeAdjustedValue(LoadInst *LI, Instruction *InsertPt,
-                                    NewGVN &gvn) const;
-  };
-
-  /// Represents an AvailableValue which can be rematerialized at the end of
-  /// the associated BasicBlock.
-  struct AvailableValueInBlock {
-    /// BB - The basic block in question.
-    BasicBlock *BB;
-
-    /// AV - The actual available value
-    AvailableValue AV;
-
-    static AvailableValueInBlock get(BasicBlock *BB, AvailableValue &&AV) {
-      AvailableValueInBlock Res;
-      Res.BB = BB;
-      Res.AV = std::move(AV);
-      return Res;
-    }
-
-    static AvailableValueInBlock get(BasicBlock *BB, Value *V,
-                                     unsigned Offset = 0) {
-      return get(BB, AvailableValue::get(V, Offset));
-    }
-    static AvailableValueInBlock getMI(BasicBlock *BB, MemIntrinsic *MI,
-                                       unsigned Offset = 0) {
-      return get(BB, AvailableValue::getMI(MI, Offset));
-    }
-    static AvailableValueInBlock getLoad(BasicBlock *BB, LoadInst *LI,
-                                         unsigned Offset = 0) {
-      return get(BB, AvailableValue::getLoad(LI, Offset));
-    }
-    static AvailableValueInBlock getUndef(BasicBlock *BB) {
-      return get(BB, AvailableValue::getUndef());
-    }
-
-    /// Emit code at the end of this block to adjust the value defined here to
-    /// the specified type. This handles various coercion cases.
-    Value *MaterializeAdjustedValue(LoadInst *LI, NewGVN &gvn) const {
-      return AV.MaterializeAdjustedValue(LI, BB->getTerminator(), gvn);
-    }
-  };
-
-  // PRE
-  typedef SmallVector<AvailableValueInBlock, 64> AvailValInBlkVect;
-  typedef SmallVector<std::pair<BasicBlock *, const Expression *>, 64>
-      UnavailBlkVect;
-  typedef SmallDenseMap<const BasicBlock *, AvailableValueInBlock>
-      AvailValInBlkMap;
-  typedef DenseMap<const BasicBlock *, char> FullyAvailableMap;
-
-  bool isValueFullyAvailableInBlock(BasicBlock *, FullyAvailableMap &,
-                                    uint32_t);
-  Value *findPRELeader(Value *, const BasicBlock *, const Value *);
-  Value *findPRELeader(const Expression *, const BasicBlock *, const Value *);
-  bool phiTranslateArguments(const BasicExpression *, BasicExpression *,
-                             const BasicBlock *, const Value *);
-  MemoryAccess *phiTranslateMemoryAccess(MemoryAccess *, const BasicBlock *);
-  const Expression *phiTranslateExpression(const Expression *E, BasicBlock *,
-                                           BasicBlock *, const Value *);
-  BasicBlock *splitCriticalEdges(BasicBlock *, BasicBlock *);
-  void analyzeAvailability(Instruction *, AvailValInBlkVect &,
-                           UnavailBlkVect &);
-  bool performPRE(Instruction *, AvailValInBlkVect &, UnavailBlkVect &);
-  bool performPREOnClass(CongruenceClass *);
-  Value *constructSSAForSet(Instruction *,
-                            SmallVectorImpl<AvailableValueInBlock> &);
-  void valueNumberNewInstruction(Value *);
-  void valueNumberNewInstructionToValue(Value *, Value *);
-  const Expression *trySimplifyPREExpression(const Expression *,
-                                             const BasicBlock *);
-  Value *regenerateExpression(const Expression *, BasicBlock *);
-  void topoVisitCongruenceClass(CongruenceClass *,
-                                SmallDenseMap<CongruenceClass *, unsigned> &,
-                                SmallPtrSetImpl<CongruenceClass *> &);
+  void updateProcessedCount(Value *V);
 };
 
 char NewGVN::ID = 0;
@@ -570,8 +307,8 @@ FunctionPass *llvm::createNewGVNPass() { return new NewGVN(); }
 static std::string getBlockName(const BasicBlock *B) {
   return DOTGraphTraits<const Function *>::getSimpleNodeLabel(B, NULL);
 }
-
 #endif
+
 INITIALIZE_PASS_BEGIN(NewGVN, "newgvn", "Global Value Numbering", false, false)
 INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)
 INITIALIZE_PASS_DEPENDENCY(MemorySSAWrapperPass)
@@ -580,7 +317,6 @@ INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)
 INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)
 INITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)
 INITIALIZE_PASS_END(NewGVN, "newgvn", "Global Value Numbering", false, false)
-
 PHIExpression *NewGVN::createPHIExpression(Instruction *I) {
   BasicBlock *PhiBlock = I->getParent();
   PHINode *PN = cast<PHINode>(I);
@@ -590,7 +326,6 @@ PHIExpression *NewGVN::createPHIExpression(Instruction *I) {
   E->allocateOperands(ArgRecycler, ExpressionAllocator);
   E->setType(I->getType());
   E->setOpcode(I->getOpcode());
-  bool UsedEquiv = false;
   for (unsigned i = 0, e = I->getNumOperands(); i != e; ++i) {
     BasicBlock *B = PN->getIncomingBlock(i);
     if (!ReachableBlocks.count(B)) {
@@ -600,14 +335,12 @@ PHIExpression *NewGVN::createPHIExpression(Instruction *I) {
     }
     if (I->getOperand(i) != I) {
       const BasicBlockEdge BBE(B, PhiBlock);
-      auto Operand = lookupOperandLeader(I->getOperand(i), BBE);
-      E->ops_push_back(Operand.first);
-      UsedEquiv |= Operand.second;
+      auto Operand = lookupOperandLeader(I->getOperand(i), I, BBE);
+      E->ops_push_back(Operand);
     } else {
       E->ops_push_back(I->getOperand(i));
     }
   }
-  E->setUsedInference(UsedEquiv);
   return E;
 }
 
@@ -617,7 +350,6 @@ PHIExpression *NewGVN::createPHIExpression(Instruction *I) {
 bool NewGVN::setBasicExpressionInfo(Instruction *I, BasicExpression *E,
                                     const BasicBlock *B) {
   bool AllConstant = true;
-  bool UsedInference = false;
   if (auto GEP = dyn_cast<GetElementPtrInst>(I))
     E->setType(GEP->getSourceElementType());
   else
@@ -626,14 +358,11 @@ bool NewGVN::setBasicExpressionInfo(Instruction *I, BasicExpression *E,
   E->allocateOperands(ArgRecycler, ExpressionAllocator);
 
   for (auto &O : I->operands()) {
-    auto Res = inferValueAtBlock(O, B);
-    auto Operand = lookupOperandLeader(O, B);
-    UsedInference |= Operand.second;
-    if (!isa<Constant>(Operand.first))
+    auto Operand = lookupOperandLeader(O, I, B);
+    if (!isa<Constant>(Operand))
       AllConstant = false;
-    E->ops_push_back(Operand.first);
+    E->ops_push_back(Operand);
   }
-  E->setUsedInference(UsedInference);
   return AllConstant;
 }
 
@@ -653,14 +382,10 @@ const Expression *NewGVN::createBinaryExpression(unsigned Opcode, Type *T,
     if (Arg1 > Arg2)
       std::swap(Arg1, Arg2);
   }
-  bool UsedEquiv = false;
-  auto BinaryLeader = lookupOperandLeader(Arg1, B);
-  UsedEquiv |= BinaryLeader.second;
-  E->ops_push_back(BinaryLeader.first);
-
-  BinaryLeader = lookupOperandLeader(Arg2, B);
-  UsedEquiv |= BinaryLeader.second;
-  E->ops_push_back(BinaryLeader.first);
+  auto BinaryLeader = lookupOperandLeader(Arg1, nullptr, B);
+  E->ops_push_back(BinaryLeader);
+  BinaryLeader = lookupOperandLeader(Arg2, nullptr, B);
+  E->ops_push_back(BinaryLeader);
 
   Value *V = SimplifyBinOp(Opcode, E->getOperand(0), E->getOperand(1), *DL, TLI,
                            DT, AC);
@@ -690,7 +415,7 @@ const Expression *NewGVN::checkSimplificationResults(Expression *E,
 
     cast<BasicExpression>(E)->deallocateOperands(ArgRecycler);
     ExpressionAllocator.Deallocate(E);
-    return createConstantExpression(C, E->usedEquivalence());
+    return createConstantExpression(C);
   } else if (isa<Argument>(V) || isa<GlobalVariable>(V)) {
 #ifndef NDEBUG
     if (I)
@@ -699,7 +424,7 @@ const Expression *NewGVN::checkSimplificationResults(Expression *E,
 #endif
     cast<BasicExpression>(E)->deallocateOperands(ArgRecycler);
     ExpressionAllocator.Deallocate(E);
-    return createVariableExpression(V, E->usedEquivalence());
+    return createVariableExpression(V);
   }
 
   CongruenceClass *CC = ValueToClass.lookup(V);
@@ -842,26 +567,24 @@ NewGVN::createAggregateValueExpression(Instruction *I, const BasicBlock *B) {
 }
 
 const VariableExpression *
-NewGVN::createVariableExpression(Value *V, bool UsedEquivalence) {
+NewGVN::createVariableExpression(Value *V) {
   VariableExpression *E = new (ExpressionAllocator) VariableExpression(V);
   E->setOpcode(V->getValueID());
-  E->setUsedInference(UsedEquivalence);
   return E;
 }
 
 const Expression *NewGVN::createVariableOrConstant(Value *V,
                                                    const BasicBlock *B) {
-  auto Leader = lookupOperandLeader(V, B);
-  if (Constant *C = dyn_cast<Constant>(Leader.first))
-    return createConstantExpression(C, Leader.second);
-  return createVariableExpression(Leader.first, Leader.second);
+  auto Leader = lookupOperandLeader(V, nullptr, B);
+  if (Constant *C = dyn_cast<Constant>(Leader))
+    return createConstantExpression(C);
+  return createVariableExpression(Leader);
 }
 
 const ConstantExpression *
-NewGVN::createConstantExpression(Constant *C, bool UsedEquivalence) {
+NewGVN::createConstantExpression(Constant *C) {
   ConstantExpression *E = new (ExpressionAllocator) ConstantExpression(C);
   E->setOpcode(C->getValueID());
-  E->setUsedInference(UsedEquivalence);
   return E;
 }
 
@@ -876,15 +599,14 @@ const CallExpression *NewGVN::createCallExpression(CallInst *CI,
 
 // lookupOperandLeader -- See if we have a congruence class and leader
 // for this operand, and if so, return it. Otherwise, return the
-// original operand.  The second part of the return value is true if a
-// dominating equivalence is being returned.
+// original operand.
 template <class T>
-std::pair<Value *, bool> NewGVN::lookupOperandLeader(Value *V,
-                                                     const T &B) const {
+Value *NewGVN::lookupOperandLeader(Value *V, const User *U,
+                                   const T &B) const {
   CongruenceClass *CC = ValueToClass.lookup(V);
   if (CC && (CC != InitialClass))
-    return std::make_pair(CC->RepLeader, false);
-  return std::make_pair(V, false);
+    return CC->RepLeader;
+  return V;
 }
 
 LoadExpression *NewGVN::createLoadExpression(Type *LoadType, Value *PointerOp,
@@ -895,30 +617,11 @@ LoadExpression *NewGVN::createLoadExpression(Type *LoadType, Value *PointerOp,
   E->setType(LoadType);
   // Give store and loads same opcode so they value number together
   E->setOpcode(0);
-  auto Operand = lookupOperandLeader(PointerOp, B);
-  E->ops_push_back(Operand.first);
+  auto Operand = lookupOperandLeader(PointerOp, LI, B);
+  E->ops_push_back(Operand);
   if (LI)
     E->setAlignment(LI->getAlignment());
-  E->setUsedInference(Operand.second);
-
-  // TODO: Value number heap versions. We may be able to discover
-  // things alias analysis can't on it's own (IE that a store and a
-  // load have the same value, and thus, it isn't clobbering the load)
-  return E;
-}
 
-const CoercibleLoadExpression *NewGVN::createCoercibleLoadExpression(
-    Type *LoadType, Value *PtrOperand, LoadInst *Original, MemoryAccess *DA,
-    unsigned Offset, Value *SrcVal, const BasicBlock *B) {
-  CoercibleLoadExpression *E = new (ExpressionAllocator)
-      CoercibleLoadExpression(1, Original, DA, Offset, SrcVal);
-  E->allocateOperands(ArgRecycler, ExpressionAllocator);
-  E->setType(LoadType);
-  // Give store and loads same opcode so they value number together
-  E->setOpcode(0);
-  auto Operand = lookupOperandLeader(PtrOperand, B);
-  E->ops_push_back(Operand.first);
-  E->setUsedInference(Operand.second);
   // TODO: Value number heap versions. We may be able to discover
   // things alias analysis can't on it's own (IE that a store and a
   // load have the same value, and thus, it isn't clobbering the load)
@@ -934,300 +637,21 @@ const StoreExpression *NewGVN::createStoreExpression(StoreInst *SI,
   E->setType(SI->getValueOperand()->getType());
   // Give store and loads same opcode so they value number together
   E->setOpcode(0);
-  auto Operand = lookupOperandLeader(SI->getPointerOperand(), B);
-  E->ops_push_back(Operand.first);
-  E->setUsedInference(Operand.second);
+  auto Operand = lookupOperandLeader(SI->getPointerOperand(), SI, B);
+  E->ops_push_back(Operand);
   // TODO: Value number heap versions. We may be able to discover
   // things alias analysis can't on it's own (IE that a store and a
   // load have the same value, and thus, it isn't clobbering the load)
   return E;
 }
 
-/// This function is called when we have a
-/// memdep query of a load that ends up being a clobbering memory write (store,
-/// memset, memcpy, memmove).  This means that the write *may* provide bits used
-/// by the load but we can't be sure because the pointers don't mustalias.
-///
-/// Check this case to see if there is anything more we can do before we give
-/// up.  This returns -1 if we have to give up, or a byte number in the stored
-/// value of the piece that feeds the load.
-int NewGVN::analyzeLoadFromClobberingWrite(Type *LoadTy, Value *LoadPtr,
-                                           Value *WritePtr,
-                                           uint64_t WriteSizeInBits) {
-  // If the loaded or stored value is a first class array or struct, don't try
-  // to transform them.  We need to be able to bitcast to integer.
-  if (LoadTy->isStructTy() || LoadTy->isArrayTy())
-    return -1;
-
-  int64_t StoreOffset = 0, LoadOffset = 0;
-  Value *StoreBase =
-      GetPointerBaseWithConstantOffset(WritePtr, StoreOffset, *DL);
-  Value *LoadBase = GetPointerBaseWithConstantOffset(LoadPtr, LoadOffset, *DL);
-  if (StoreBase != LoadBase)
-    return -1;
-
-  // If the load and store don't overlap at all, the store doesn't provide
-  // anything to the load.  In this case, they really don't alias at all, AA
-  // must have gotten confused.
-  uint64_t LoadSize = DL->getTypeSizeInBits(LoadTy);
-
-  if ((WriteSizeInBits & 7) | (LoadSize & 7))
-    return -1;
-  uint64_t StoreSize = WriteSizeInBits >> 3; // Convert to bytes.
-  LoadSize >>= 3;
-
-  bool isAAFailure = false;
-  if (StoreOffset < LoadOffset)
-    isAAFailure = StoreOffset + int64_t(StoreSize) <= LoadOffset;
-  else
-    isAAFailure = LoadOffset + int64_t(LoadSize) <= StoreOffset;
-
-  if (isAAFailure) {
-    return -1;
-  }
-
-  // If the Load isn't completely contained within the stored bits, we don't
-  // have all the bits to feed it.  We could do something crazy in the future
-  // (issue a smaller load then merge the bits in) but this seems unlikely to be
-  // valuable.
-  if (StoreOffset > LoadOffset ||
-      StoreOffset + StoreSize < LoadOffset + LoadSize)
-    return -1;
-
-  // Okay, we can do this transformation.  Return the number of bytes into the
-  // store that the load is.
-  return LoadOffset - StoreOffset;
-}
-
-/// This function is called when we have a
-/// memdep query of a load that ends up being a clobbering store.
-int NewGVN::analyzeLoadFromClobberingStore(Type *LoadTy, Value *LoadPtr,
-                                           StoreInst *DepSI) {
-
-  // Cannot handle reading from store of first-class aggregate yet.
-  if (DepSI->getValueOperand()->getType()->isStructTy() ||
-      DepSI->getValueOperand()->getType()->isArrayTy())
-    return -1;
-
-  Value *StorePtr = DepSI->getPointerOperand();
-  uint64_t StoreSize =
-      DL->getTypeSizeInBits(DepSI->getValueOperand()->getType());
-  return analyzeLoadFromClobberingWrite(LoadTy, LoadPtr, StorePtr, StoreSize);
-}
-
-/// This function is called when we have a
-/// memdep query of a load that ends up being clobbered by another load.  See if
-/// the other load can feed into the second load.
-int NewGVN::analyzeLoadFromClobberingLoad(Type *LoadTy, Value *LoadPtr,
-                                          LoadInst *DepLI) {
-  // Cannot handle reading from store of first-class aggregate yet.
-  if (DepLI->getType()->isStructTy() || DepLI->getType()->isArrayTy())
-    return -1;
-
-  Value *DepPtr = DepLI->getPointerOperand();
-  uint64_t DepSize = DL->getTypeSizeInBits(DepLI->getType());
-  int Offset = analyzeLoadFromClobberingWrite(LoadTy, LoadPtr, DepPtr, DepSize);
-
-  if (Offset != -1) {
-    // If the size is too large and we will have to widen, ensure we pass the
-    // widening rules below
-    unsigned SrcValSize = DL->getTypeStoreSize(DepLI->getType());
-    unsigned LoadSize = DL->getTypeStoreSize(LoadTy);
-    if (Offset + LoadSize <= SrcValSize)
-      return Offset;
-  }
-
-  // If we have a load/load clobber an DepLI can be widened to cover this load,
-  // then we should widen it!
-  int64_t LoadOffs = 0;
-  const Value *LoadBase =
-      GetPointerBaseWithConstantOffset(LoadPtr, LoadOffs, *DL);
-  unsigned LoadSize = DL->getTypeStoreSize(LoadTy);
-
-  unsigned Size = MemoryDependenceResults::getLoadLoadClobberFullWidthSize(
-      LoadBase, LoadOffs, LoadSize, DepLI);
-  if (Size == 0)
-    return -1;
-
-  return analyzeLoadFromClobberingWrite(LoadTy, LoadPtr, DepPtr, Size * 8);
-}
-
-int NewGVN::analyzeLoadFromClobberingMemInst(Type *LoadTy, Value *LoadPtr,
-                                             MemIntrinsic *MI) {
-  // If the mem operation is a non-constant size, we can't handle it.
-  ConstantInt *SizeCst = dyn_cast<ConstantInt>(MI->getLength());
-  if (!SizeCst)
-    return -1;
-  uint64_t MemSizeInBits = SizeCst->getZExtValue() * 8;
-
-  // If this is memset, we just need to see if the offset is valid in the size
-  // of the memset..
-  if (MI->getIntrinsicID() == Intrinsic::memset)
-    return analyzeLoadFromClobberingWrite(LoadTy, LoadPtr, MI->getDest(),
-                                          MemSizeInBits);
-
-  // If we have a memcpy/memmove, the only case we can handle is if this is a
-  // copy from constant memory.  In that case, we can read directly from the
-  // constant memory.
-  MemTransferInst *MTI = cast<MemTransferInst>(MI);
-
-  Constant *Src = dyn_cast<Constant>(MTI->getSource());
-  if (!Src)
-    return -1;
-
-  GlobalVariable *GV = dyn_cast<GlobalVariable>(GetUnderlyingObject(Src, *DL));
-  if (!GV || !GV->isConstant())
-    return -1;
-
-  // See if the access is within the bounds of the transfer.
-  int Offset = analyzeLoadFromClobberingWrite(LoadTy, LoadPtr, MI->getDest(),
-                                              MemSizeInBits);
-  if (Offset == -1)
-    return Offset;
-
-  unsigned AS = Src->getType()->getPointerAddressSpace();
-  // Otherwise, see if we can constant fold a load from the constant with the
-  // offset applied as appropriate.
-  Src =
-      ConstantExpr::getBitCast(Src, Type::getInt8PtrTy(Src->getContext(), AS));
-  Constant *OffsetCst =
-      ConstantInt::get(Type::getInt64Ty(Src->getContext()), (unsigned)Offset);
-  Src = ConstantExpr::getGetElementPtr(Type::getInt8Ty(Src->getContext()), Src,
-                                       OffsetCst);
-  Src = ConstantExpr::getBitCast(Src, PointerType::get(LoadTy, AS));
-  if (ConstantFoldLoadFromConstPtr(Src, LoadTy, *DL))
-    return Offset;
-  return -1;
-}
-
 const Expression *NewGVN::performSymbolicStoreEvaluation(Instruction *I,
                                                          const BasicBlock *B) {
   StoreInst *SI = cast<StoreInst>(I);
-  const Expression *E =
-      createStoreExpression(SI, MSSAWalker->getClobberingMemoryAccess(SI), B);
+  const Expression *E = createStoreExpression(SI, MSSA->getMemoryAccess(SI), B);
   return E;
 }
 
-const Expression *
-NewGVN::performSymbolicLoadCoercionFromPhi(Type *LoadType, Value *LoadPtr,
-                                           LoadInst *LI, MemoryPhi *DefiningPhi,
-                                           const BasicBlock *B) {
-  if (!LoadPtr)
-    return nullptr;
-  AvailValInBlkVect ValuesPerBlock;
-  for (auto &Op : DefiningPhi->operands()) {
-    BasicBlock *IncomingBlock = DefiningPhi->getIncomingBlock(Op);
-    // If the block is not reachable, it's undef
-    if (!ReachableBlocks.count(IncomingBlock)) {
-      ValuesPerBlock.push_back(AvailableValueInBlock::getUndef(IncomingBlock));
-      continue;
-    }
-    // FIXME: We don't support phi over phi
-    if (isa<MemoryPhi>(Op))
-      return nullptr;
-    const MemoryDef *Def = cast<MemoryDef>(Op);
-    Instruction *Inst = Def->getMemoryInst();
-    if (!Inst)
-      return nullptr;
-    // If the dependence is to a store that writes to a superset of the bits
-    // read by the load, we can extract the bits we need for the load from the
-    // stored value.
-    if (StoreInst *DepSI = dyn_cast<StoreInst>(Inst)) {
-      int Offset = analyzeLoadFromClobberingStore(LoadType, LoadPtr, DepSI);
-      if (Offset != -1) {
-        ValuesPerBlock.push_back(AvailableValueInBlock::get(
-            Def->getBlock(), DepSI->getValueOperand(), Offset));
-        continue;
-      }
-    }
-    // Check to see if we have something like this:
-    //    load i32* P
-    //    load i8* (P+1)
-    // if we have this, replace the later with an extraction from the former.
-    if (LoadInst *DepLI = dyn_cast<LoadInst>(Inst)) {
-      // If this is a clobber and L is the first instruction in its block, then
-      // we have the first instruction in the entry block.
-      if (DepLI != LI) {
-        int Offset = analyzeLoadFromClobberingLoad(LoadType, LoadPtr, DepLI);
-
-        if (Offset != -1) {
-          ValuesPerBlock.push_back(
-              AvailableValueInBlock::getLoad(Def->getBlock(), DepLI, Offset));
-          continue;
-        }
-      }
-    }
-    // If the clobbering value is a memset/memcpy/memmove, see if we can
-    // forward a value on from it.
-    if (MemIntrinsic *DepMI = dyn_cast<MemIntrinsic>(Inst)) {
-      int Offset = analyzeLoadFromClobberingMemInst(LoadType, LoadPtr, DepMI);
-      if (Offset != -1) {
-        Value *PossibleConstant =
-            getMemInstValueForLoad(DepMI, Offset, LoadType, LI, true);
-        ValuesPerBlock.push_back(
-            AvailableValueInBlock::getMI(Def->getBlock(), DepMI, Offset));
-        continue;
-      }
-    }
-    return nullptr;
-  }
-  assert(ValuesPerBlock.size() == DefiningPhi->getNumIncomingValues());
-  return nullptr;
-}
-
-const Expression *NewGVN::performSymbolicLoadCoercion(
-    Type *LoadType, Value *LoadPtr, LoadInst *LI, Instruction *DepInst,
-    MemoryAccess *DefiningAccess, const BasicBlock *B) {
-  assert((!LI || LI->isSimple()) && "Not a simple load");
-
-  if (StoreInst *DepSI = dyn_cast<StoreInst>(DepInst)) {
-    Value *LoadAddressLeader = lookupOperandLeader(LoadPtr, B).first;
-    Value *StoreAddressLeader =
-        lookupOperandLeader(DepSI->getPointerOperand(), B).first;
-    Value *StoreVal = DepSI->getValueOperand();
-    if (StoreVal->getType() == LoadType &&
-        LoadAddressLeader == StoreAddressLeader) {
-      return createVariableOrConstant(DepSI->getValueOperand(), B);
-    } else {
-      int Offset = analyzeLoadFromClobberingStore(LoadType, LoadPtr, DepSI);
-      if (Offset >= 0)
-        return createCoercibleLoadExpression(
-            LoadType, LoadPtr, LI, DefiningAccess, (unsigned)Offset, DepSI, B);
-    }
-  } else if (LoadInst *DepLI = dyn_cast<LoadInst>(DepInst)) {
-    int Offset = analyzeLoadFromClobberingLoad(LoadType, LoadPtr, DepLI);
-    if (Offset >= 0)
-      return createCoercibleLoadExpression(
-          LoadType, LoadPtr, LI, DefiningAccess, (unsigned)Offset, DepLI, B);
-  } else if (MemIntrinsic *DepMI = dyn_cast<MemIntrinsic>(DepInst)) {
-    int Offset = analyzeLoadFromClobberingMemInst(LoadType, LoadPtr, DepMI);
-    if (Offset >= 0)
-      return createCoercibleLoadExpression(
-          LoadType, LoadPtr, LI, DefiningAccess, (unsigned)Offset, DepMI, B);
-  }
-  // If this load really doesn't depend on anything, then we must be loading
-  // an
-  // undef value.  This can happen when loading for a fresh allocation with
-  // no
-  // intervening stores, for example.
-  else if (isa<AllocaInst>(DepInst) || isMallocLikeFn(DepInst, TLI))
-    return createConstantExpression(UndefValue::get(LoadType), false);
-
-  // If this load occurs either right after a lifetime begin,
-  // then the loaded value is undefined.
-  else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(DepInst)) {
-    if (II->getIntrinsicID() == Intrinsic::lifetime_start)
-      return createConstantExpression(UndefValue::get(LoadType), false);
-  }
-  // If this load follows a calloc (which zero initializes memory),
-  // then the loaded value is zero
-  else if (isCallocLikeFn(DepInst, TLI)) {
-    return createConstantExpression(Constant::getNullValue(LoadType), false);
-  }
-
-  return nullptr;
-}
-
 const Expression *NewGVN::performSymbolicLoadEvaluation(Instruction *I,
                                                         const BasicBlock *B) {
   LoadInst *LI = cast<LoadInst>(I);
@@ -1238,10 +662,10 @@ const Expression *NewGVN::performSymbolicLoadEvaluation(Instruction *I,
     return nullptr;
 
   Value *LoadAddressLeader =
-      lookupOperandLeader(LI->getPointerOperand(), B).first;
+      lookupOperandLeader(LI->getPointerOperand(), I, B);
   // Load of undef is undef
   if (isa<UndefValue>(LoadAddressLeader))
-    return createConstantExpression(UndefValue::get(LI->getType()), false);
+    return createConstantExpression(UndefValue::get(LI->getType()));
 
   MemoryAccess *DefiningAccess = MSSAWalker->getClobberingMemoryAccess(I);
 
@@ -1251,58 +675,7 @@ const Expression *NewGVN::performSymbolicLoadEvaluation(Instruction *I,
       // If the defining instruction is not reachable, replace with
       // undef
       if (!ReachableBlocks.count(DefiningInst->getParent()))
-        return createConstantExpression(UndefValue::get(LI->getType()), false);
-      const Expression *CoercionResult =
-          performSymbolicLoadCoercion(LI->getType(), LI->getPointerOperand(),
-                                      LI, DefiningInst, DefiningAccess, B);
-      if (CoercionResult)
-        return CoercionResult;
-    } else if (MemoryPhi *MP = dyn_cast<MemoryPhi>(DefiningAccess)) {
-      const Expression *CoercionResult = performSymbolicLoadCoercionFromPhi(
-          LI->getType(), LI->getPointerOperand(), LI, MP, B);
-      if (CoercionResult)
-        return CoercionResult;
-    }
-  } else {
-    BasicBlock *LoadBlock = LI->getParent();
-    MemoryAccess *LoadAccess = MSSA->getMemoryAccess(LI);
-    // Okay, so uh, we couldn't use the defining access to grab a value out of
-    // See if we can reuse any of it's uses by widening a load.
-    for (const auto &U : DefiningAccess->users()) {
-      MemoryAccess *MA = cast<MemoryAccess>(U);
-      if (MA == LoadAccess)
-        continue;
-      if (isa<MemoryPhi>(MA))
-        continue;
-      Instruction *DefiningInst = cast<MemoryUseOrDef>(MA)->getMemoryInst();
-      if (LoadInst *DepLI = dyn_cast<LoadInst>(DefiningInst)) {
-        BasicBlock *DefiningBlock = DefiningInst->getParent();
-        if (!DT->dominates(DefiningBlock, LoadBlock))
-          continue;
-
-        // Make sure the dependent load comes before the load we are trying
-        // to coerce if they are in the same block
-        if (InstrDFS[DepLI] >= InstrDFS[LI])
-          continue;
-
-        // Now, first make sure they really aren't identical loads, and if
-        // they aren't see if the dominating one can be coerced.
-        // We don't want to mark identical loads coercible, since coercible
-        // loads don't value number with normal loads.
-        Value *DepAddressLeader =
-            lookupOperandLeader(DepLI->getPointerOperand(), B).first;
-
-        if (LI->getType() != DepLI->getType() ||
-            DepAddressLeader != LoadAddressLeader ||
-            LI->isSimple() != DepLI->isSimple()) {
-          int Offset = analyzeLoadFromClobberingLoad(
-              LI->getType(), LI->getPointerOperand(), DepLI);
-          if (Offset >= 0)
-            return createCoercibleLoadExpression(
-                LI->getType(), LI->getPointerOperand(), LI, DefiningAccess,
-                (unsigned)Offset, DepLI, B);
-        }
-      }
+        return createConstantExpression(UndefValue::get(LI->getType()));
     }
   }
 
@@ -1335,7 +708,7 @@ const Expression *NewGVN::performSymbolicPHIEvaluation(Instruction *I,
                  << "\n");
     E->deallocateOperands(ArgRecycler);
     ExpressionAllocator.Deallocate(E);
-    return createConstantExpression(UndefValue::get(I->getType()), false);
+    return createConstantExpression(UndefValue::get(I->getType()));
   }
 
   Value *AllSameValue = E->getOperand(0);
@@ -1369,8 +742,8 @@ const Expression *NewGVN::performSymbolicPHIEvaluation(Instruction *I,
     E->deallocateOperands(ArgRecycler);
     ExpressionAllocator.Deallocate(E);
     if (Constant *C = dyn_cast<Constant>(AllSameValue))
-      return createConstantExpression(C, E->usedEquivalence());
-    return createVariableExpression(AllSameValue, E->usedEquivalence());
+      return createConstantExpression(C);
+    return createVariableExpression(AllSameValue);
   }
   return E;
 }
@@ -1421,12 +794,11 @@ NewGVN::performSymbolicAggrValueEvaluation(Instruction *I,
 /// before value numbering
 const Expression *NewGVN::performSymbolicEvaluation(Value *V,
                                                     const BasicBlock *B) {
-  // XXX: Use forward propagation by substituting DefiningExpr
   const Expression *E = NULL;
   if (Constant *C = dyn_cast<Constant>(V))
-    E = createConstantExpression(C, false);
+    E = createConstantExpression(C);
   else if (isa<Argument>(V) || isa<GlobalVariable>(V)) {
-    E = createVariableExpression(V, false);
+    E = createVariableExpression(V);
   } else {
     // TODO: memory intrinsics
     // TODO: Some day, we should do the forward propagation and reassociation
@@ -1509,14 +881,7 @@ bool NewGVN::isOnlyReachableViaThisEdge(const BasicBlockEdge &E) {
 // only reachable from Src, in practice it is pointless since at the time
 // GVN runs all such loops have preheaders, which means that Dst will have
 // been changed to have only one predecessor, namely Src.
-#if 0
-  BasicBlock *EdgeEnd = const_cast<BasicBlock *>(E.getEnd());
-  if (PredCache.size(EdgeEnd) != 1)
-    return false;
-  const BasicBlock *Pred = PredCache.get(EdgeEnd)[0];
-#else
   const BasicBlock *Pred = E.getEnd()->getSinglePredecessor();
-#endif
   const BasicBlock *Src = E.getStart();
   assert((!Pred || Pred == Src) && "No edge between these basic blocks!");
   (void)Src;
@@ -1600,31 +965,16 @@ void NewGVN::performCongruenceFinding(Value *V, const Expression *E) {
       DEBUG(dbgs() << "New congruence class for " << V << " is " << EClass->ID
                    << "\n");
 
-      if (E && isa<CoercibleLoadExpression>(E)) {
-        const CoercibleLoadExpression *L = cast<CoercibleLoadExpression>(E);
-        VClass->CoercibleMembers.erase(V);
-        EClass->CoercibleMembers.insert(V);
-        CoercionInfo.insert(
-            std::make_pair(V, std::make_pair(L->getOffset(), L->getSrc())));
-      } else {
-        VClass->Members.erase(V);
-        EClass->Members.insert(V);
-      }
-
+      VClass->Members.erase(V);
+      EClass->Members.insert(V);
       ValueToClass[V] = EClass;
       // See if we destroyed the class or need to swap leaders
-      if ((VClass->Members.empty() && VClass->CoercibleMembers.empty()) &&
-          VClass != InitialClass) {
+      if (VClass->Members.empty() && VClass != InitialClass) {
         if (VClass->DefiningExpr) {
           VClass->Dead = true;
-
           DEBUG(dbgs() << "Erasing expression " << *E << " from table\n");
-          // bool wasE = *E == *VClass->expression;
           ExpressionToClass.erase(VClass->DefiningExpr);
-          // if (wasE)
-          //   lookupMap->insert({E, EClass});
         }
-        // delete VClass;
       } else if (VClass->RepLeader == V) {
         /// XXX: Check this. When the leader changes, the value numbering of
         /// everything may change, so we need to reprocess.
@@ -1634,11 +984,6 @@ void NewGVN::performCongruenceFinding(Value *V, const Expression *E) {
             TouchedInstructions.set(InstrDFS[I]);
           ChangedValues.insert(M);
         }
-        for (auto EM : VClass->CoercibleMembers) {
-          if (Instruction *I = dyn_cast<Instruction>(EM))
-            TouchedInstructions.set(InstrDFS[I]);
-          ChangedValues.insert(EM);
-        }
       }
     }
     markUsersTouched(V);
@@ -1653,12 +998,10 @@ void NewGVN::updateReachableEdge(BasicBlock *From, BasicBlock *To) {
   if (ReachableEdges.insert({From, To}).second) {
     // If this block wasn't reachable before, all instructions are touched
     if (ReachableBlocks.insert(To).second) {
-      SingleReachableIncoming.insert({To, From});
       DEBUG(dbgs() << "Block " << getBlockName(To) << " marked reachable\n");
       const auto &InstRange = BlockInstRange.lookup(To);
       TouchedInstructions.set(InstRange.first, InstRange.second);
     } else {
-      SingleReachableIncoming.erase(To);
       DEBUG(dbgs() << "Block " << getBlockName(To)
                    << " was reachable, but new edge {" << getBlockName(From)
                    << "," << getBlockName(To) << "} to it found\n");
@@ -1672,8 +1015,6 @@ void NewGVN::updateReachableEdge(BasicBlock *From, BasicBlock *To) {
         TouchedInstructions.set(InstrDFS[&*BI]);
         ++BI;
       }
-      // Propagate the change downstream.
-      propagateChangeInEdge(To);
     }
   }
 }
@@ -1682,43 +1023,11 @@ void NewGVN::updateReachableEdge(BasicBlock *From, BasicBlock *To) {
 // switch, cmp, or whatever) and a block, see if we know some constant
 // value for it already
 Value *NewGVN::findConditionEquivalence(Value *Cond, BasicBlock *B) const {
-  auto Result = lookupOperandLeader(Cond, B);
-  if (isa<Constant>(Result.first))
-    return Result.first;
-
+  auto Result = lookupOperandLeader(Cond, nullptr, B);
+  if (isa<Constant>(Result))
+    return Result;
   return nullptr;
 }
-Value *NewGVN::inferValueAtBlock(Value *V, const BasicBlock *B) const {
-  V = lookupOperandLeader(V, B).first;
-  if (isa<Constant>(V))
-    return V;
-  const BasicBlock *FirstBlock = B;
-  const BasicBlock *LastBlock = nullptr;
-  while (!isa<Constant>(V) && B != LastBlock) {
-    B = FirstBlock;
-    while (B != LastBlock) {
-      const BasicBlock *SingleIncomingBlock = SingleReachableIncoming.lookup(B);
-      if (!SingleIncomingBlock) {
-        const auto DomNode = DT->getNode(B)->getIDom();
-        if (!DomNode) {
-          B = LastBlock;
-          break;
-        }
-
-        B = DomNode->getBlock();
-        continue;
-      }
-      const auto EPI = EdgePredicates.find({SingleIncomingBlock, B});
-      if (EPI != EdgePredicates.end()) {
-        for (const auto &Predicate : EPI->second)
-          if (Predicate.First == V || Predicate.Second == V)
-            DEBUG(dbgs() << "Edge Predicate found for value " << *V << " \n");
-      }
-      B = SingleIncomingBlock;
-    }
-  }
-  return V;
-}
 
 //  processOutgoingEdges - Process the outgoing edges of a block for
 //  reachability.
@@ -1738,37 +1047,10 @@ void NewGVN::processOutgoingEdges(TerminatorInst *TI, BasicBlock *B) {
       } else if (isa<ConstantInt>(Cond)) {
         CondEvaluated = Cond;
       }
-    } else {
-      InvolvedInEquivalence.set(InstrDFS[TI]);
     }
     ConstantInt *CI;
     BasicBlock *TrueSucc = BR->getSuccessor(0);
     BasicBlock *FalseSucc = BR->getSuccessor(1);
-    // Start with the true predicate
-    if (CmpInst *CI = dyn_cast<CmpInst>(Cond)) {
-      CmpInst::Predicate Predicate = CI->getPredicate();
-      Value *Op0 = CI->getOperand(0);
-      Value *Op1 = CI->getOperand(1);
-      EdgePredicate EP = {Op0, Predicate, Op1,
-                          ConstantInt::getTrue(B->getContext())};
-      // Make a consistent order for predicates
-      if (Op0 > Op1) {
-        std::swap(EP.First, EP.Second);
-        EP.Op = CmpInst::getSwappedPredicate(EP.Op);
-      }
-
-      // XXX: Infer value of predicate
-      // XXX: Recompute predicates properly
-      const auto EPT = EdgePredicates[{B, TrueSucc}].insert(EP);
-      if (!EPT.second)
-        propagateChangeInEdge(TrueSucc);
-
-      EP.Val = ConstantInt::getFalse(B->getContext());
-      const auto EPF = EdgePredicates[{B, FalseSucc}].insert(EP);
-      if (!EPF.second)
-        propagateChangeInEdge(FalseSucc);
-    }
-
     if (CondEvaluated && (CI = dyn_cast<ConstantInt>(CondEvaluated))) {
       if (CI->isOne()) {
         DEBUG(dbgs() << "Condition for Terminator " << *TI
@@ -1780,13 +1062,6 @@ void NewGVN::processOutgoingEdges(TerminatorInst *TI, BasicBlock *B) {
         updateReachableEdge(B, FalseSucc);
       }
     } else {
-      /* XXX:Predicates
-      propagateEquality(Cond, ConstantInt::getTrue(TrueSucc->getContext()),
-                        false, {B, TrueSucc});
-
-      propagateEquality(Cond, ConstantInt::getFalse(FalseSucc->getContext()),
-                        false, {B, FalseSucc});
-      */
       updateReachableEdge(B, TrueSucc);
       updateReachableEdge(B, FalseSucc);
     }
@@ -1802,7 +1077,6 @@ void NewGVN::processOutgoingEdges(TerminatorInst *TI, BasicBlock *B) {
     Value *CondEvaluated = findConditionEquivalence(SwitchCond, B);
     // See if we were able to turn this switch statement into a constant
     if (CondEvaluated && isa<ConstantInt>(CondEvaluated)) {
-      InvolvedInEquivalence.set(InstrDFS[TI]);
       ConstantInt *CondVal = cast<ConstantInt>(CondEvaluated);
       // We should be able to get case value for this
       auto CaseVal = SI->findCaseValue(CondVal);
@@ -1827,27 +1101,12 @@ void NewGVN::processOutgoingEdges(TerminatorInst *TI, BasicBlock *B) {
         if (Block == TargetBlock)
           MultipleEdgesOneReachable = true;
       }
-      const BasicBlockEdge E(B, TargetBlock);
-      /* XXX:Predicates
-      propagateEquality(SwitchCond, CaseVal.getCaseValue(),
-      MultipleEdgesOneReachable, E);*/
     } else {
       for (unsigned i = 0, e = SI->getNumSuccessors(); i != e; ++i) {
         BasicBlock *TargetBlock = SI->getSuccessor(i);
         ++SwitchEdges[TargetBlock];
         updateReachableEdge(B, TargetBlock);
       }
-      /*XXX:Predicates
-      // Regardless of answers, propagate equalities for case values
-      for (auto i = SI->case_begin(), e = SI->case_end(); i != e; ++i) {
-        BasicBlock *TargetBlock = i.getCaseSuccessor();
-        if (SwitchEdges.lookup(TargetBlock) == 1) {
-          const BasicBlockEdge E(B, TargetBlock);
-          propagateEquality(SwitchCond, i.getCaseValue(),
-                            MultipleEdgesOneReachable, E);
-        }
-        }
-      */
     }
   } else {
     // Otherwise this is either unconditional, or a type we have no
@@ -1859,98 +1118,17 @@ void NewGVN::processOutgoingEdges(TerminatorInst *TI, BasicBlock *B) {
   }
 }
 
-// Figure out and cache the dominated instruction range for this block. We do
-// this by doing a depth first search, and figuring out the min and the max of
-// the dominated instruction range.
-// On the way up, we cache the ranges for all the child blocks.
-// This is essentially an incremental DFS
-
-const std::pair<unsigned, unsigned>
-NewGVN::calculateDominatedInstRange(const DomTreeNode *DTN) {
-
-  // First see if we have it, if not, we need to recalculate
-  const auto &DominatedRange = DominatedInstRange.find(DTN);
-  if (DominatedRange != DominatedInstRange.end()) {
-    return DominatedRange->second;
-  }
-  // Recalculate
-  SmallVector<std::pair<const DomTreeNode *, DomTreeNode::const_iterator>, 32>
-      WorkStack;
-  WorkStack.emplace_back(DTN, DTN->begin());
-  unsigned MaxSeen = 0;
-  while (!WorkStack.empty()) {
-    const auto &Back = WorkStack.back();
-    const DomTreeNode *Node = Back.first;
-    auto ChildIt = Back.second;
-    const auto &Result = BlockInstRange.lookup(Node->getBlock());
-    MaxSeen = std::max(MaxSeen, Result.second);
-    // If we visited all of the children of this node, "recurse" back up the
-    // stack setting the ranges
-    if (ChildIt == Node->end()) {
-      const auto &Result = BlockInstRange.lookup(Node->getBlock());
-      DominatedInstRange[DTN] = {Result.first, MaxSeen};
-      WorkStack.pop_back();
-      if (WorkStack.empty())
-        return {Result.first, MaxSeen};
-    } else {
-      while (ChildIt != Node->end()) {
-        // Otherwise, recursively visit this child.
-        const DomTreeNode *Child = *ChildIt;
-        ++WorkStack.back().second;
-        const auto &LookupResult = DominatedInstRange.find(Child);
-        if (LookupResult == DominatedInstRange.end()) {
-          WorkStack.emplace_back(Child, Child->begin());
-          break;
-        } else {
-          // We already have calculated this subtree
-          MaxSeen = std::max(MaxSeen, LookupResult->second.second);
-          ++ChildIt;
-        }
-      }
-    }
-  }
-  llvm_unreachable("Should have returned a value already");
-}
-
-/// propagateChangeInEdge - Propagate a change in edge reachability
-// When we discover a new edge to an existing reachable block, that
-// can affect the value of instructions that used equivalences.
-//
-void NewGVN::propagateChangeInEdge(BasicBlock *Dest) {
-  // Unlike, the published algorithm, we don't touch blocks because we aren't
-  // recomputing predicates.
-  // Instead, we touch all the instructions we dominate that were used in an
-  // equivalence, in case they changed.
-  // We incrementally compute the dominated instruction ranges, because doing it
-  // up front requires a DFS walk of the dominator tree that is a complete waste
-  // of time if no equivalences ever get seen.
-  // Note that we expect phi nodes in the Dest block will have already been
-  // touched by our caller.
-  DomTreeNode *DTN = DT->getNode(Dest);
-
-  // Note that this is an overshoot, because the inst ranges are calculated in
-  // RPO order, not dominator tree order.
-  const std::pair<unsigned, unsigned> Result = calculateDominatedInstRange(DTN);
-
-  // Touch all the downstream dominated instructions that used equivalences.
-  for (int InstrNum = InvolvedInEquivalence.find_next(Result.first - 1);
-       InstrNum != -1 && (Result.second - InstrNum > 0);
-       InstrNum = InvolvedInEquivalence.find_next(InstrNum)) {
-    // TODO: We could do confluence block checks here.
-    TouchedInstructions.set(InstrNum);
-  }
-}
-
+// The algorithm initially places the values of the routine in the INITIAL congruence
+// class. The leader of INITIAL is the undetermined value `TOP`.
+// When the algorithm has finished, values still in INITIAL are unreachable.
 void NewGVN::initializeCongruenceClasses(Function &F) {
   // FIXME now i can't remember why this is 2
   NextCongruenceNum = 2;
   // Initialize all other instructions to be in INITIAL class
   CongruenceClass::MemberSet InitialValues;
-  for (auto &B : F) {
-    for (auto &I : B) {
+  for (auto &B : F)
+    for (auto &I : B)
       InitialValues.insert(&I);
-    }
-  }
 
   InitialClass = createCongruenceClass(NULL, NULL);
   for (auto L : InitialValues)
@@ -1964,22 +1142,21 @@ void NewGVN::initializeCongruenceClasses(Function &F) {
 }
 
 void NewGVN::cleanupTables() {
-
-  ValueToClass.clear();
+#ifndef NDEBUG
   for (unsigned i = 0, e = CongruenceClasses.size(); i != e; ++i) {
     DEBUG(dbgs() << "Congruence class " << CongruenceClasses[i]->ID << " has "
                  << CongruenceClasses[i]->Members.size() << " members\n");
   }
+#endif
 
+  ValueToClass.clear();
   ArgRecycler.clear(ExpressionAllocator);
   ExpressionAllocator.Reset();
   CongruenceClasses.clear();
   ExpressionToClass.clear();
   ValueToExpression.clear();
-  SingleReachableIncoming.clear();
   ReachableBlocks.clear();
   ReachableEdges.clear();
-  EdgePredicates.clear();
   ProcessedCount.clear();
   DFSDomMap.clear();
   InstrDFS.clear();
@@ -1988,11 +1165,7 @@ void NewGVN::cleanupTables() {
   DFSToInstr.clear();
   BlockInstRange.clear();
   TouchedInstructions.clear();
-  InvolvedInEquivalence.clear();
-  CoercionInfo.clear();
-  CoercionForwarding.clear();
   DominatedInstRange.clear();
-  PredCache.clear();
 }
 
 std::pair<unsigned, unsigned> NewGVN::assignDFSNumbers(BasicBlock *B,
@@ -2009,30 +1182,23 @@ std::pair<unsigned, unsigned> NewGVN::assignDFSNumbers(BasicBlock *B,
   return std::make_pair(Start, End);
 }
 
-void NewGVN::topoVisitCongruenceClass(
-    CongruenceClass *CC, SmallDenseMap<CongruenceClass *, unsigned> &UsedCount,
-    SmallPtrSetImpl<CongruenceClass *> &Visited) {
-  Visited.insert(CC);
-  // Visit the classes of the values of the operands of the leader set
-  for (auto Member : CC->Members) {
-    if (User *U = dyn_cast<User>(Member)) {
-      for (auto &I : U->operands()) {
-        CongruenceClass *OperandCC = ValueToClass.lookup(I);
-        if (OperandCC) {
-          UsedCount[OperandCC] += 1;
-          if (!Visited.count(OperandCC))
-            topoVisitCongruenceClass(OperandCC, UsedCount, Visited);
-        }
-      }
-    }
+void NewGVN::updateProcessedCount(Value *V) {
+#ifndef NDEBUG
+  if (ProcessedCount.count(V) == 0) {
+    ProcessedCount.insert({V, 1});
+  } else {
+    ProcessedCount[V] += 1;
+    assert(ProcessedCount[V] < 100 &&
+           "Seem to have processed the same Value a lot\n");
   }
+#endif
 }
 
 /// runOnFunction - This is the main transformation entry point for a
 /// function.
 bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
-                    TargetLibraryInfo *TLI, AliasAnalysis *AA,
-                    MemorySSA *MSSA) {
+                   TargetLibraryInfo *TLI, AliasAnalysis *AA,
+                   MemorySSA *MSSA) {
   bool Changed = false;
   this->DT = DT;
   this->AC = AC;
@@ -2042,12 +1208,9 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
   DL = &F.getParent()->getDataLayout();
   MSSAWalker = MSSA->getWalker();
 
-  //  SplitAllCriticalEdges(F, CriticalEdgeSplittingOptions(AA, DT));
-
-  unsigned ICount = 0;
   // Count number of instructions for sizing of hash tables, and come
-  // up with a global dfs numbering for instructions
-
+  // up with a global dfs numbering for instructions.
+  unsigned ICount = 0;
   SmallPtrSet<BasicBlock *, 16> VisitedBlocks;
 
   // Note: We want RPO traversal of the blocks, which is not quite the same as
@@ -2056,7 +1219,7 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
   // If we visit in the wrong order, we will end up performing N times as many
   // iterations.
   ReversePostOrderTraversal<Function *> RPOT(&F);
-  for (BasicBlock *B : RPOT) {
+  for (auto &B : RPOT) {
     VisitedBlocks.insert(B);
     const auto &BlockRange = assignDFSNumbers(B, ICount);
     BlockInstRange.insert({B, BlockRange});
@@ -2066,7 +1229,7 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
   // Handle forward unreachable blocks and figure out which blocks
   // have single preds
 
-  for (BasicBlock &B : F) {
+  for (auto &B : F) {
     // Assign numbers to unreachable blocks
     if (!VisitedBlocks.count(&B)) {
       const auto &BlockRange = assignDFSNumbers(&B, ICount);
@@ -2076,7 +1239,6 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
   }
 
   TouchedInstructions.resize(ICount + 1);
-  InvolvedInEquivalence.resize(ICount + 1);
   DominatedInstRange.reserve(F.size());
   // Ensure we don't end up resizing the expressionToClass map, as
   // that can be quite expensive. At most, we have one expression per
@@ -2112,17 +1274,7 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
                        << " because it is unreachable\n");
           continue;
         }
-        //#ifndef NDEBUG
-        if (ProcessedCount.count(CurrBlock) == 0) {
-          ProcessedCount.insert({CurrBlock, 1});
-        } else {
-          ProcessedCount[CurrBlock] += 1;
-          assert(ProcessedCount[CurrBlock] < 100 &&
-                 "Seem to have processed the same block a lot\n");
-          if (ProcessedCount[CurrBlock] >= 100)
-            report_fatal_error("Processed block too many times");
-        }
-        //#endif
+        updateProcessedCount(CurrBlock);
       }
       DEBUG(dbgs() << "Processing instruction " << *I << "\n");
       if (I->use_empty() && !I->getType()->isVoidTy()) {
@@ -2132,23 +1284,12 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
         TouchedInstructions.reset(InstrNum);
         continue;
       }
+      updateProcessedCount(I);
 
-// This is done in case something eliminates the instruction
-// along the way.
-
-#ifndef NDEBUG
-      if (ProcessedCount.count(I) == 0) {
-        ProcessedCount.insert({I, 1});
-      } else {
-        ProcessedCount[I] += 1;
-        assert(ProcessedCount[I] < 100 &&
-               "Seem to have processed the same instruction a lot");
-      }
-#endif
+      // This is done in case something eliminates the instruction
+      // along the way.
       if (!I->isTerminator()) {
         const Expression *Symbolized = performSymbolicEvaluation(I, CurrBlock);
-        if (Symbolized && Symbolized->usedEquivalence())
-          InvolvedInEquivalence.set(InstrDFS[I]);
         performCongruenceFinding(I, Symbolized);
       } else {
         processOutgoingEdges(dyn_cast<TerminatorInst>(I), CurrBlock);
@@ -2161,53 +1302,6 @@ bool NewGVN::runGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,
 
   Changed |= eliminateInstructions(F);
 
-// The ideal ordering for processing is not quite topological ordering,
-// because there are multiple roots.  It is essentially "group every vertex
-// that depends on a given vertex together after that vertex", which is not
-// the same.  It is in fact, an NP complete problem, and given that the graph
-// may be cyclic anyway, we order the congruence classes by how many things
-// depend on them.  This is a good approximation, and will cut down the number
-// of iterations.
-#if 0
-  SmallDenseMap<CongruenceClass *, unsigned> UsedCount;
-  SmallPtrSet<CongruenceClass *, 16> VisitedClasses;
-
-  for (int i = CongruenceClasses.size() - 1; i >= 0; --i) {
-    CongruenceClass *CC = CongruenceClasses[i];
-    if (CC == InitialClass || CC->dead || VisitedClasses.count(CC))
-      continue;
-    topoVisitCongruenceClass(CC, UsedCount, VisitedClasses);
-  }
-  SmallVector<CongruenceClass *, 16> Worklist;
-  for (auto &CC : CongruenceClasses)
-    Worklist.push_back(CC);
-  // std::sort(Worklist.begin(), Worklist.end(),
-  //           [&UsedCount](CongruenceClass *&A, CongruenceClass *&B) {
-  //             return UsedCount[A] > UsedCount[B];
-  //           });
-
-  bool PREChanged = true;
-  while (PREChanged) {
-    PREChanged = false;
-#if 1
-    // FIXME: Handle added congruence classes
-    if (Worklist.size() != CongruenceClasses.size())
-      Worklist.insert(Worklist.end(),
-                      CongruenceClasses.begin() + (Worklist.size() - 1),
-                      CongruenceClasses.end());
-#endif
-    for (auto CC : Worklist) {
-      if (CC == InitialClass || CC->dead)
-        continue;
-
-      PREChanged |= performPREOnClass(CC);
-    }
-  }
-
-  PREValueForwarding.clear();
-
-  Changed |= PREChanged;
-#endif
   // Delete all instructions marked for deletion.
   for (Instruction *ToErase : InstructionsToErase) {
     if (!ToErase->use_empty())
@@ -2241,7 +1335,8 @@ bool NewGVN::runOnFunction(Function &F) {
                 &getAnalysis<MemorySSAWrapperPass>().getMSSA());
 }
 
-PreservedAnalyses NewGVNPass::run(Function &F, AnalysisManager<Function> &AM) {
+PreservedAnalyses NewGVNPass::run(Function &F,
+                                  AnalysisManager<Function> &AM) {
   NewGVN Impl;
 
   // Apparently the order in which we get these results matter for
@@ -2280,13 +1375,11 @@ struct NewGVN::ValueDFS {
   int DFSIn;
   int DFSOut;
   int LocalNum;
-  bool Coercible;
   // Only one of these will be set
   Value *Val;
   Use *U;
   ValueDFS()
-      : DFSIn(0), DFSOut(0), LocalNum(0), Coercible(false), Val(nullptr),
-        U(nullptr) {}
+      : DFSIn(0), DFSOut(0), LocalNum(0), Val(nullptr), U(nullptr) {}
 
   bool operator<(const ValueDFS &other) const {
     // It's not enough that any given field be less than - we have sets
@@ -2309,8 +1402,6 @@ struct NewGVN::ValueDFS {
         if (LocalNum < other.LocalNum)
           return true;
         else if (LocalNum == other.LocalNum) {
-          if (!!Coercible < !!other.Coercible)
-            return true;
           if (Val < other.Val)
             return true;
           if (U < other.U)
@@ -2323,8 +1414,7 @@ struct NewGVN::ValueDFS {
 };
 
 void NewGVN::convertDenseToDFSOrdered(CongruenceClass::MemberSet &Dense,
-                                      std::vector<ValueDFS> &DFSOrderedSet,
-                                      bool Coercible) {
+                                      std::vector<ValueDFS> &DFSOrderedSet) {
   for (auto D : Dense) {
     // First add the value
     BasicBlock *BB = getBlockForValue(D);
@@ -2338,7 +1428,6 @@ void NewGVN::convertDenseToDFSOrdered(CongruenceClass::MemberSet &Dense,
     VD.DFSIn = DFSPair.first;
     VD.DFSOut = DFSPair.second;
     VD.Val = D;
-    VD.Coercible = Coercible;
     // If it's an instruction, use the real local dfs number,
     if (Instruction *I = dyn_cast<Instruction>(D))
       VD.LocalNum = InstrDFS[I];
@@ -2351,7 +1440,6 @@ void NewGVN::convertDenseToDFSOrdered(CongruenceClass::MemberSet &Dense,
     for (auto &U : D->uses()) {
       if (Instruction *I = dyn_cast<Instruction>(U.getUser())) {
         ValueDFS VD;
-        VD.Coercible = Coercible;
         // Put the phi node uses in the incoming block
         BasicBlock *IBlock;
         if (PHINode *P = dyn_cast<PHINode>(I)) {
@@ -2426,30 +1514,11 @@ void NewGVN::deleteInstructionsInBlock(BasicBlock *BB) {
     if (!Inst.use_empty())
       Inst.replaceAllUsesWith(UndefValue::get(Inst.getType()));
     if (isa<LandingPadInst>(Inst))
-        continue;
+      continue;
 
     Inst.eraseFromParent();
     ++NumGVNInstrDeleted;
   }
-#if 0
-  // Delete the instructions backwards, as it has a reduced likelihood of having
-  // to update as many def-use and use-def chains.
-  Instruction *EndInst = BB->getTerminator(); // Last not to be deleted.
-  while (EndInst->getIterator() != BB->begin()) {
-    // Delete the next to last instruction.
-    BasicBlock::iterator I = EndInst->getIterator();
-    Instruction *Inst = &*--I;
-    if (!Inst->use_empty())
-      Inst->replaceAllUsesWith(UndefValue::get(Inst->getType()));
-    if (isa<LandingPadInst>(Inst)) {
-      EndInst = Inst;
-      continue;
-    }
-    Inst->eraseFromParent();
-    BB->getInstList().erase(Inst);
-    ++NumGVNInstrDeleted;
-  }
-#endif
 }
 
 void NewGVN::markInstructionForDeletion(Instruction *I) {
@@ -2504,372 +1573,6 @@ private:
 };
 }
 
-/// CanCoerceMustAliasedValueToLoad - Return true if
-/// CoerceAvailableValueToLoadType will succeed.
-bool NewGVN::canCoerceMustAliasedValueToLoad(Value *StoredVal, Type *LoadTy) {
-
-  // If the loaded or stored value is an first class array or struct, don't
-  // try
-  // to transform them.  We need to be able to bitcast to integer.
-  if (LoadTy->isStructTy() || LoadTy->isArrayTy() ||
-      StoredVal->getType()->isStructTy() || StoredVal->getType()->isArrayTy())
-    return false;
-
-  // The store has to be at least as big as the load.
-  if (DL->getTypeSizeInBits(StoredVal->getType()) <
-      DL->getTypeSizeInBits(LoadTy))
-    return false;
-
-  return true;
-}
-
-/// CoerceAvailableValueToLoadType - If we saw a store of a value to memory,
-/// and
-/// then a load from a must-aliased pointer of a different type, try to coerce
-/// the stored value.  LoadedTy is the type of the load we want to replace and
-/// InsertPt is the place to insert new instructions.
-///
-/// If we can't do it, return null.
-Value *NewGVN::coerceAvailableValueToLoadType(Value *StoredVal, Type *LoadedTy,
-                                              Instruction *InsertPt) {
-
-  if (!canCoerceMustAliasedValueToLoad(StoredVal, LoadedTy))
-    return 0;
-
-  // If this is already the right type, just return it.
-  Type *StoredValTy = StoredVal->getType();
-
-  uint64_t StoreSize = DL->getTypeSizeInBits(StoredValTy);
-  uint64_t LoadSize = DL->getTypeSizeInBits(LoadedTy);
-
-  // If the store and reload are the same size, we can always reuse it.
-  if (StoreSize == LoadSize) {
-    // Pointer to Pointer -> use bitcast.
-    if (StoredValTy->isPointerTy() && LoadedTy->isPointerTy()) {
-      Instruction *I = new BitCastInst(StoredVal, LoadedTy, "", InsertPt);
-      handleNewInstruction(I);
-      return I;
-    }
-
-    // Convert source pointers to integers, which can be bitcast.
-    if (StoredValTy->isPointerTy()) {
-      StoredValTy = DL->getIntPtrType(StoredValTy->getContext());
-      Instruction *I = new PtrToIntInst(StoredVal, StoredValTy, "", InsertPt);
-      StoredVal = I;
-      handleNewInstruction(I);
-    }
-
-    Type *TypeToCastTo = LoadedTy;
-    if (TypeToCastTo->isPointerTy())
-      TypeToCastTo = DL->getIntPtrType(StoredValTy->getContext());
-
-    if (StoredValTy != TypeToCastTo) {
-      Instruction *I = new BitCastInst(StoredVal, TypeToCastTo, "", InsertPt);
-      StoredVal = I;
-      handleNewInstruction(I);
-    }
-
-    // Cast to pointer if the load needs a pointer type.
-    if (LoadedTy->isPointerTy()) {
-      Instruction *I = new IntToPtrInst(StoredVal, LoadedTy, "", InsertPt);
-      StoredVal = I;
-      handleNewInstruction(I);
-    }
-    return StoredVal;
-  }
-
-  // If the loaded value is smaller than the available value, then we can
-  // extract out a piece from it.  If the available value is too small, then
-  // we
-  // can't do anything.
-  assert(StoreSize >= LoadSize && "CanCoerceMustAliasedValueToLoad fail");
-
-  // Convert source pointers to integers, which can be manipulated.
-  if (StoredValTy->isPointerTy()) {
-    StoredValTy = DL->getIntPtrType(StoredValTy->getContext());
-    Instruction *I = new PtrToIntInst(StoredVal, StoredValTy, "", InsertPt);
-    StoredVal = I;
-    handleNewInstruction(I);
-  }
-
-  // Convert vectors and fp to integer, which can be manipulated.
-  if (!StoredValTy->isIntegerTy()) {
-    StoredValTy = IntegerType::get(StoredValTy->getContext(), StoreSize);
-    Instruction *I = new BitCastInst(StoredVal, StoredValTy, "", InsertPt);
-    StoredVal = I;
-    handleNewInstruction(I);
-  }
-
-  // If this is a big-endian system, we need to shift the value down to the
-  // low
-  // bits so that a truncate will work.
-  if (DL->isBigEndian()) {
-    Constant *Val =
-        ConstantInt::get(StoredVal->getType(), StoreSize - LoadSize);
-    StoredVal = BinaryOperator::CreateLShr(StoredVal, Val, "tmp", InsertPt);
-    if (Instruction *I = dyn_cast<Instruction>(StoredVal))
-      handleNewInstruction(I);
-  }
-
-  // Truncate the integer to the right size now.
-  Type *NewIntTy = IntegerType::get(StoredValTy->getContext(), LoadSize);
-  Instruction *I = new TruncInst(StoredVal, NewIntTy, "trunc", InsertPt);
-  StoredVal = I;
-  handleNewInstruction(I);
-
-  if (LoadedTy == NewIntTy)
-    return StoredVal;
-
-  // If the result is a pointer, inttoptr.
-  if (LoadedTy->isPointerTy()) {
-    I = new IntToPtrInst(StoredVal, LoadedTy, "inttoptr", InsertPt);
-    handleNewInstruction(I);
-    return I;
-  }
-
-  // Otherwise, bitcast.
-  I = new BitCastInst(StoredVal, LoadedTy, "bitcast", InsertPt);
-  handleNewInstruction(I);
-  return I;
-}
-
-/// GetStoreValueForLoad - This function is called when we have a
-/// memdep query of a load that ends up being a clobbering store.  This means
-/// that the store provides bits used by the load but we the pointers don't
-/// mustalias.  Check this case to see if there is anything more we can do
-/// before we give up.
-Value *NewGVN::getStoreValueForLoad(Value *SrcVal, unsigned Offset,
-                                    Type *LoadTy, Instruction *InsertPt) {
-
-  LLVMContext &Ctx = SrcVal->getType()->getContext();
-
-  uint64_t StoreSize = (DL->getTypeSizeInBits(SrcVal->getType()) + 7) / 8;
-  uint64_t LoadSize = (DL->getTypeSizeInBits(LoadTy) + 7) / 8;
-
-  IRBuilder<> Builder(InsertPt);
-
-  // Compute which bits of the stored value are being used by the load.  Convert
-  // to an integer type to start with.
-  if (SrcVal->getType()->getScalarType()->isPointerTy()) {
-    SrcVal =
-        Builder.CreatePtrToInt(SrcVal, DL->getIntPtrType(SrcVal->getType()));
-    if (Instruction *I = dyn_cast<Instruction>(SrcVal))
-      handleNewInstruction(I);
-  }
-
-  if (!SrcVal->getType()->isIntegerTy()) {
-    SrcVal =
-        Builder.CreateBitCast(SrcVal, IntegerType::get(Ctx, StoreSize * 8));
-    if (Instruction *I = dyn_cast<Instruction>(SrcVal))
-      handleNewInstruction(I);
-  }
-  // Shift the bits to the least significant depending on endianness.
-  unsigned ShiftAmt;
-  if (DL->isLittleEndian())
-    ShiftAmt = Offset * 8;
-  else
-    ShiftAmt = (StoreSize - LoadSize - Offset) * 8;
-
-  if (ShiftAmt) {
-    SrcVal = Builder.CreateLShr(SrcVal, ShiftAmt);
-    if (Instruction *I = dyn_cast<Instruction>(SrcVal))
-      handleNewInstruction(I);
-  }
-  if (LoadSize != StoreSize) {
-    SrcVal = Builder.CreateTrunc(SrcVal, IntegerType::get(Ctx, LoadSize * 8));
-    if (Instruction *I = dyn_cast<Instruction>(SrcVal))
-      handleNewInstruction(I);
-  }
-  return coerceAvailableValueToLoadType(SrcVal, LoadTy, InsertPt);
-}
-
-/// GetLoadValueForLoad - This function is called when we have a
-/// memdep query of a load that ends up being a clobbering load.  This means
-/// that the load *may* provide bits used by the load but we can't be sure
-/// because the pointers don't mustalias.  Check this case to see if there is
-/// anything more we can do before we give up.
-Value *NewGVN::getLoadValueForLoad(LoadInst *SrcVal, unsigned Offset,
-                                   Type *LoadTy, Instruction *InsertPt) {
-  // If Offset+LoadTy exceeds the size of SrcVal, then we must be wanting to
-  // widen SrcVal out to a larger load.
-  unsigned SrcValSize = DL->getTypeStoreSize(SrcVal->getType());
-  unsigned LoadSize = DL->getTypeStoreSize(LoadTy);
-  if (Offset + LoadSize > SrcValSize) {
-    assert(SrcVal->isSimple() && "Cannot widen volatile/atomic load!");
-    assert(SrcVal->getType()->isIntegerTy() && "Can't widen non-integer load");
-    // If we have a load/load clobber an DepLI can be widened to cover this
-    // load, then we should widen it to the next power of 2 size big enough!
-    unsigned NewLoadSize = Offset + LoadSize;
-    if (!isPowerOf2_32(NewLoadSize))
-      NewLoadSize = NextPowerOf2(NewLoadSize);
-
-    Value *PtrVal = SrcVal->getPointerOperand();
-
-    // Insert the new load after the old load.  This ensures that subsequent
-    // memdep queries will find the new load.  We can't easily remove the old
-    // load completely because it is already in the value numbering table.
-    IRBuilder<> Builder(SrcVal->getParent(), ++(SrcVal->getIterator()));
-    Type *DestPTy = IntegerType::get(LoadTy->getContext(), NewLoadSize * 8);
-    DestPTy =
-        PointerType::get(DestPTy, PtrVal->getType()->getPointerAddressSpace());
-    Builder.SetCurrentDebugLocation(SrcVal->getDebugLoc());
-    PtrVal = Builder.CreateBitCast(PtrVal, DestPTy);
-    if (Instruction *I = dyn_cast<Instruction>(PtrVal))
-      handleNewInstruction(I);
-    LoadInst *NewLoad = Builder.CreateLoad(PtrVal);
-    NewLoad->takeName(SrcVal);
-    NewLoad->setAlignment(SrcVal->getAlignment());
-    handleNewInstruction(NewLoad);
-    DEBUG(dbgs() << "GVN WIDENED LOAD: " << *SrcVal << "\n");
-    DEBUG(dbgs() << "TO: " << *NewLoad << "\n");
-    // This ensures we forward other coercions onto the new load, instead of the
-    // old one
-    CoercionForwarding[SrcVal] = NewLoad;
-
-    // Replace uses of the original load with the wider load.  On a big endian
-    // system, we need to shift down to get the relevant bits.
-    Value *RV = NewLoad;
-    if (DL->isBigEndian()) {
-      RV = Builder.CreateLShr(
-          RV, NewLoadSize * 8 - SrcVal->getType()->getPrimitiveSizeInBits());
-      if (Instruction *I = dyn_cast<Instruction>(RV))
-        handleNewInstruction(I);
-    }
-
-    RV = Builder.CreateTrunc(RV, SrcVal->getType());
-    if (Instruction *I = dyn_cast<Instruction>(RV))
-      handleNewInstruction(I);
-
-    // markUsersTouched(SrcVal);
-    // assert(false && "Need to debug this");
-    // So, we just widened a load that we will have already gone past in
-    // elimination, so in order to get rid of the uses, we have to do it here
-
-    SrcVal->replaceAllUsesWith(RV);
-
-    // We would like to use gvn.markInstructionForDeletion here, but we can't
-    // because the load is already memoized into the leader map table that GVN
-    // tracks.  It is potentially possible to remove the load from the table,
-    // but then there all of the operations based on it would need to be
-    // rehashed.  Just leave the dead load around.
-    // FIXME: This is no longer a problem
-    markInstructionForDeletion(SrcVal);
-    SrcVal = NewLoad;
-  }
-
-  return getStoreValueForLoad(SrcVal, Offset, LoadTy, InsertPt);
-}
-
-/// GetMemInstValueForLoad - This function is called when we have a
-/// memdep query of a load that ends up being a clobbering mem intrinsic.
-Value *NewGVN::getMemInstValueForLoad(MemIntrinsic *SrcInst, unsigned Offset,
-                                      Type *LoadTy, Instruction *InsertPt,
-                                      bool NoNewInst) {
-
-  LLVMContext &Ctx = LoadTy->getContext();
-  uint64_t LoadSize = DL->getTypeSizeInBits(LoadTy) / 8;
-
-  IRBuilder<> Builder(InsertPt);
-
-  // We know that this method is only called when the mem transfer fully
-  // provides the bits for the load.
-  if (MemSetInst *MSI = dyn_cast<MemSetInst>(SrcInst)) {
-    // memset(P, 'x', 1234) -> splat('x'), even if x is a variable, and
-    // independently of what the offset is.
-    Value *Val = MSI->getValue();
-    if (LoadSize != 1) {
-      if (NoNewInst)
-        return nullptr;
-      Val = Builder.CreateZExt(Val, IntegerType::get(Ctx, LoadSize * 8));
-      if (Instruction *I = dyn_cast<Instruction>(Val))
-        handleNewInstruction(I);
-    }
-
-    Value *OneElt = Val;
-
-    // Splat the value out to the right number of bits.
-    for (unsigned NumBytesSet = 1; NumBytesSet != LoadSize;) {
-      if (NoNewInst)
-        return nullptr;
-
-      // If we can double the number of bytes set, do it.
-      if (NumBytesSet * 2 <= LoadSize) {
-        Value *ShVal = Builder.CreateShl(Val, NumBytesSet * 8);
-        if (Instruction *I = dyn_cast<Instruction>(ShVal))
-          handleNewInstruction(I);
-        Val = Builder.CreateOr(Val, ShVal);
-        if (Instruction *I = dyn_cast<Instruction>(Val))
-          handleNewInstruction(I);
-        NumBytesSet <<= 1;
-        continue;
-      }
-
-      // Otherwise insert one byte at a time.
-      Value *ShVal = Builder.CreateShl(Val, 1 * 8);
-      if (Instruction *I = dyn_cast<Instruction>(ShVal))
-        handleNewInstruction(I);
-
-      Val = Builder.CreateOr(OneElt, ShVal);
-      if (Instruction *I = dyn_cast<Instruction>(Val))
-        handleNewInstruction(I);
-
-      ++NumBytesSet;
-    }
-
-    return coerceAvailableValueToLoadType(Val, LoadTy, InsertPt);
-  }
-
-  // Otherwise, this is a memcpy/memmove from a constant global.
-  MemTransferInst *MTI = cast<MemTransferInst>(SrcInst);
-  Constant *Src = cast<Constant>(MTI->getSource());
-  unsigned AS = Src->getType()->getPointerAddressSpace();
-
-  // Otherwise, see if we can constant fold a load from the constant with the
-  // offset applied as appropriate.
-  Src = ConstantExpr::getBitCast(
-      Src, llvm::Type::getInt8PtrTy(Src->getContext(), AS));
-  Constant *OffsetCst =
-      ConstantInt::get(Type::getInt64Ty(Src->getContext()), (unsigned)Offset);
-  Src = ConstantExpr::getGetElementPtr(Type::getInt8Ty(Src->getContext()), Src,
-                                       OffsetCst);
-  Src = ConstantExpr::getBitCast(Src, PointerType::get(LoadTy, AS));
-  return ConstantFoldLoadFromConstPtr(Src, LoadTy, *DL);
-}
-
-Value *NewGVN::coerceLoad(Value *V) {
-  assert(isa<LoadInst>(V) && "Trying to coerce something other than a load");
-  LoadInst *LI = cast<LoadInst>(V);
-  // This is an offset, source pair
-  const std::pair<unsigned, Value *> &Info = CoercionInfo.lookup(LI);
-  Value *Result;
-  Value *RealValue = Info.second;
-  // Walk all the coercion fowarding chains, in case this load has already been
-  // widened into another load
-  while (true) {
-    auto ForwardingResult = CoercionForwarding.find(RealValue);
-    if (ForwardingResult != CoercionForwarding.end())
-      RealValue = ForwardingResult->second;
-    else
-      break;
-  }
-
-  assert(DT->dominates(cast<Instruction>(RealValue), LI) &&
-         "Trying to replace a load with one that doesn't dominate it");
-  if (StoreInst *DepSI = dyn_cast<StoreInst>(RealValue))
-    Result = getStoreValueForLoad(DepSI->getValueOperand(), Info.first,
-                                  LI->getType(), LI);
-  else if (LoadInst *DepLI = dyn_cast<LoadInst>(RealValue))
-    Result = getLoadValueForLoad(DepLI, Info.first, LI->getType(), LI);
-  else if (MemIntrinsic *DepMI = dyn_cast<MemIntrinsic>(RealValue))
-    Result = getMemInstValueForLoad(DepMI, Info.first, LI->getType(), LI);
-  else
-    llvm_unreachable("Unknown coercion type");
-
-  assert(Result && "Should have been able to coerce");
-  DEBUG(dbgs() << "Coerced load " << *LI << " output is " << *Result << "\n");
-  return Result;
-}
-
 bool NewGVN::eliminateInstructions(Function &F) {
   // This is a non-standard eliminator. The normal way to eliminate is
   // to walk the dominator tree in order, keeping track of available
@@ -2960,9 +1663,8 @@ bool NewGVN::eliminateInstructions(Function &F) {
 
     } else {
       DEBUG(dbgs() << "Eliminating in congruence class " << CC->ID << "\n");
-      // If this is a singleton, with no equivalences or coercible members, we
-      // can skip it
-      if (CC->Members.size() != 1 || !CC->CoercibleMembers.empty()) {
+      // If this is a singleton, we can skip it
+      if (CC->Members.size() != 1) {
 
         // This is a stack because equality replacement/etc may place
         // constants in the middle of the member list, and we want to use
@@ -2971,11 +1673,11 @@ bool NewGVN::eliminateInstructions(Function &F) {
 
         ValueDFSStack EliminationStack;
 
-        // Convert the members and equivalences to DFS ordered sets and
+        // Convert the members to DFS ordered sets and
         // then merge them.
         std::vector<ValueDFS> DFSOrderedSet;
-        convertDenseToDFSOrdered(CC->Members, DFSOrderedSet, false);
-        convertDenseToDFSOrdered(CC->CoercibleMembers, DFSOrderedSet, true);
+        convertDenseToDFSOrdered(CC->Members, DFSOrderedSet);
+
         // Sort the whole thing
         sort(DFSOrderedSet.begin(), DFSOrderedSet.end());
 
@@ -2984,7 +1686,6 @@ bool NewGVN::eliminateInstructions(Function &F) {
           int MemberDFSOut = C.DFSOut;
           Value *Member = C.Val;
           Use *MemberUse = C.U;
-          bool Coercible = C.Coercible;
 
           // We ignore void things because we can't get a value from
           // them.
@@ -3027,8 +1728,6 @@ bool NewGVN::eliminateInstructions(Function &F) {
             // Push if we need to
             ShouldPush |= Member && EliminationStack.empty();
             if (ShouldPush) {
-              if (Coercible)
-                Member = coerceLoad(Member);
               EliminationStack.push_back(Member, MemberDFSIn, MemberDFSOut);
             }
           }
@@ -3084,630 +1783,8 @@ bool NewGVN::eliminateInstructions(Function &F) {
       MembersLeft.insert(Member);
     }
     CC->Members.swap(MembersLeft);
-    CC->CoercibleMembers.clear();
   }
 
   return AnythingReplaced;
 }
 
-Value *NewGVN::AvailableValue::MaterializeAdjustedValue(LoadInst *LI,
-                                                        Instruction *InsertPt,
-                                                        NewGVN &gvn) const {
-  Value *Res;
-  Type *LoadTy = LI->getType();
-
-  if (isSimpleValue()) {
-    Res = getSimpleValue();
-    if (Res->getType() != LoadTy) {
-      Res = gvn.getStoreValueForLoad(Res, Offset, LoadTy, InsertPt);
-
-      DEBUG(dbgs() << "GVN COERCED NONLOCAL VAL:\nOffset: " << Offset << "  "
-                   << *getSimpleValue() << '\n'
-                   << *Res << '\n'
-                   << "\n\n\n");
-    }
-  } else if (isCoercedLoadValue()) {
-    LoadInst *Load = getCoercedLoadValue();
-    if (Load->getType() == LoadTy && Offset == 0) {
-      Res = Load;
-    } else {
-      Res = gvn.getLoadValueForLoad(Load, Offset, LoadTy, InsertPt);
-
-      DEBUG(dbgs() << "GVN COERCED NONLOCAL LOAD:\nOffset: " << Offset << "  "
-                   << *getCoercedLoadValue() << '\n'
-                   << *Res << '\n'
-                   << "\n\n\n");
-    }
-  } else if (isMemIntrinValue()) {
-    Res = gvn.getMemInstValueForLoad(getMemIntrinValue(), Offset, LoadTy,
-                                     InsertPt);
-    DEBUG(dbgs() << "GVN COERCED NONLOCAL MEM INTRIN:\nOffset: " << Offset
-                 << "  " << *getMemIntrinValue() << '\n'
-                 << *Res << '\n'
-                 << "\n\n\n");
-  } else {
-    assert(isUndefValue() && "Should be UndefVal");
-    DEBUG(dbgs() << "GVN COERCED NONLOCAL Undef:\n";);
-    return UndefValue::get(LoadTy);
-  }
-  assert(Res && "failed to materialize?");
-  return Res;
-}
-#if 0
-Value *
-NewGVN::AvailableValueInBlock::MaterializeAdjustedValue(Instruction *I,
-                                                        NewGVN &gvn) const {
-  if (!isa<LoadInst>(I)) {
-    assert((isSimpleValue() || isUndefValue()) &&
-           "Should have been a simple or undef value for a non-load!");
-    if (isSimpleValue())
-      return getSimpleValue();
-    else
-      return UndefValue::get(I->getType());
-  }
-
-  Value *Res;
-  Type *LoadTy = I->getType();
-
-  if (isSimpleValue()) {
-    Res = getSimpleValue();
-    if (Res->getType() != LoadTy) {
-      Res = gvn.getStoreValueForLoad(Res, Offset, LoadTy, BB->getTerminator());
-
-      DEBUG(dbgs() << "GVN COERCED NONLOCAL VAL:\nOffset: " << Offset << "  "
-                   << *getSimpleValue() << '\n' << *Res << '\n' << "\n\n\n");
-    }
-  } else if (isCoercedLoadValue()) {
-    LoadInst *Load = getCoercedLoadValue();
-    if (Load->getType() == LoadTy && Offset == 0) {
-      Res = Load;
-    } else {
-      Res = gvn.getLoadValueForLoad(Load, Offset, LoadTy, BB->getTerminator());
-
-      DEBUG(dbgs() << "GVN COERCED NONLOCAL LOAD:\nOffset: " << Offset << "  "
-                   << *getCoercedLoadValue() << '\n' << *Res << '\n'
-                   << "\n\n\n");
-    }
-  } else if (isMemIntrinValue()) {
-    Res = gvn.getMemInstValueForLoad(getMemIntrinValue(), Offset, LoadTy,
-                                     BB->getTerminator());
-    DEBUG(dbgs() << "GVN COERCED NONLOCAL MEM INTRIN:\nOffset: " << Offset
-                 << "  " << *getMemIntrinValue() << '\n' << *Res << '\n'
-                 << "\n\n\n");
-  } else {
-    assert(isUndefValue() && "Should be UndefVal");
-    DEBUG(dbgs() << "GVN COERCED NONLOCAL Undef:\n";);
-    return UndefValue::get(LoadTy);
-  }
-  return Res;
-}
-#endif
-Value *NewGVN::constructSSAForSet(
-    Instruction *I, SmallVectorImpl<AvailableValueInBlock> &ValuesPerBlock) {
-  // Check for the fully redundant, dominating load case.  In this case, we can
-  // just use the dominating value directly.
-  if (ValuesPerBlock.size() == 1 &&
-      DT->properlyDominates(ValuesPerBlock[0].BB, I->getParent())) {
-    assert(!ValuesPerBlock[0].AV.isUndefValue() &&
-           "Dead BB dominate this block");
-    return ValuesPerBlock[0].MaterializeAdjustedValue(cast<LoadInst>(I), *this);
-  }
-  // Otherwise, we have to construct SSA form.
-  SmallVector<PHINode *, 8> NewPHIs;
-  SSAUpdater SSAUpdate(&NewPHIs);
-  SSAUpdate.Initialize(I->getType(), I->getName());
-
-  for (unsigned i = 0, e = ValuesPerBlock.size(); i != e; ++i) {
-    const AvailableValueInBlock &AV = ValuesPerBlock[i];
-    BasicBlock *BB = AV.BB;
-
-    if (SSAUpdate.HasValueForBlock(BB))
-      continue;
-
-    SSAUpdate.AddAvailableValue(
-        BB, AV.MaterializeAdjustedValue(cast<LoadInst>(I), *this));
-  }
-
-  // Perform PHI construction.
-  Value *V = SSAUpdate.GetValueInMiddleOfBlock(I->getParent());
-
-  return V;
-}
-
-/// Split the critical edge connecting the given two blocks, and return
-/// the block inserted to the critical edge.
-BasicBlock *NewGVN::splitCriticalEdges(BasicBlock *Pred, BasicBlock *Succ) {
-  BasicBlock *BB =
-      SplitCriticalEdge(Pred, Succ, CriticalEdgeSplittingOptions(DT));
-  if (MD)
-    MD->invalidateCachedPredecessors();
-  return BB;
-}
-
-void NewGVN::valueNumberNewInstructionToValue(Value *New, Value *Old) {
-  if (!ValueToClass.count(New))
-    ValueToClass[New] = InitialClass;
-  const Expression *NewExpr = createVariableExpression(Old, false);
-  performCongruenceFinding(New, NewExpr);
-}
-
-void NewGVN::valueNumberNewInstruction(Value *V) {
-  if (!ValueToClass.count(V))
-    ValueToClass[V] = InitialClass;
-  const Expression *NewExpr =
-      performSymbolicEvaluation(V, cast<Instruction>(V)->getParent());
-  performCongruenceFinding(V, NewExpr);
-}
-
-Value *NewGVN::regenerateExpression(const Expression *E, BasicBlock *BB) {
-#if FIXME
-  Value *V = findPRELeader(E, BB, nullptr);
-  if (V)
-    return V;
-  if (const LoadExpression *LE = dyn_cast<LoadExpression>(E)) {
-    LoadInst *LI = new LoadInst(LE->getOperand(0), "loadpre", false,
-                                LE->getAlignment(), BB->getTerminator());
-    const_cast<LoadExpression *>(LE)->setLoadInst(LI);
-    MSSA->addNewMemoryUse(LI, MemorySSA::InsertionPlace::End);
-
-    return LI;
-  } else if (const BasicExpression *BE = dyn_cast<BasicExpression>(E)) {
-    unsigned Opcode = BE->getOpcode();
-    if (Instruction::isBinaryOp(Opcode)) {
-      BinaryOperator *BO = BinaryOperator::Create(
-          Instruction::BinaryOps(Opcode), BE->getOperand(0), BE->getOperand(1),
-          "binaryoppre", BB->getTerminator());
-      // FIXME: Track NSW/NUW
-      return BO;
-    } else if (Opcode == Instruction::MemoryOps::GetElementPtr) {
-#if FIXME
-      // It wants the pointee type, which is complex, and not equivalent to
-      // getType on the original GEP
-      // FIXME: Store getSrcType on the GEP
-      Type *PointeeType =
-          cast<SequentialType>(BE->getOperand(0)->getType()->getScalarType())
-              ->getElementType();
-#endif
-      Value *GEP = nullptr;
-      if (Value *V = SimplifyGEPInst(
-              BE->getType(), makeArrayRef(BE->ops_begin(), BE->ops_end()), *DL,
-              TLI, DT, AC))
-        GEP = V;
-      else
-        GEP = GetElementPtrInst::Create(
-            BE->getType(), BE->getOperand(0),
-            makeArrayRef(BE->ops_begin(), BE->ops_end()).slice(1), "geppre",
-            BB->getTerminator());
-      // FIXME: Track inbounds
-      return GEP;
-    } else if (((Opcode & 0xff00) >> 8) == Instruction::ICmp) {
-      CmpInst::Predicate Pred = (CmpInst::Predicate)(Opcode & 0xff);
-      ICmpInst *Cmp = new ICmpInst(BB->getTerminator(), Pred, BE->getOperand(0),
-                                   BE->getOperand(1), "icmppre");
-      return Cmp;
-    } else if (((Opcode & 0xff00) >> 8) == Instruction::FCmp) {
-      CmpInst::Predicate Pred = (CmpInst::Predicate)(Opcode & 0xff);
-      FCmpInst *Cmp = new FCmpInst(BB->getTerminator(), Pred, BE->getOperand(0),
-                                   BE->getOperand(1), "fcmppre");
-      return Cmp;
-    } else
-      llvm_unreachable("What!");
-  }
-  llvm_unreachable("What!");
-#endif
-  return nullptr;
-}
-
-bool NewGVN::performPRE(Instruction *I, AvailValInBlkVect &ValuesPerBlock,
-                        UnavailBlkVect &UnavailableBlocks) {
-  bool Changed = false;
-  // Okay, we have *some* definitions of the value.  This means that the value
-  // is available in some of our (transitive) predecessors.  Lets think about
-  // doing PRE of this instruction.  This will involve inserting a new
-  // instruction into the
-  // predecessor when it's not available.  We could do this in general, but
-  // prefer to not increase code size.  As such, we only do this when we know
-  // that we only have to insert *one* load (which means we're basically moving
-  // the load, not inserting a new one).
-
-  // Decide whether PRE is profitable for this load.
-  unsigned NumUnavailablePreds = UnavailableBlocks.size();
-  assert(NumUnavailablePreds != 0 &&
-         "Fully available value should already be eliminated!");
-
-  // If this load is unavailable in multiple predecessors, reject it.
-  // FIXME: If we could restructure the CFG, we could make a common pred with
-  // all the preds that don't have an available LI and insert a new load into
-  // that one block.
-  if (NumUnavailablePreds > 2)
-    return false;
-
-  // Check if the load can safely be moved to all the unavailable predecessors.
-  bool CanDoPRE = true;
-
-  SmallVector<Instruction *, 8> NewInsts;
-  // FIXME: Insert Can Be Avail stuff here
-  if (!CanDoPRE) {
-    while (!NewInsts.empty()) {
-      Instruction *I = NewInsts.pop_back_val();
-      if (MD)
-        MD->removeInstruction(I);
-      I->eraseFromParent();
-    }
-    // HINT: Don't revert the edge-splitting as following transformation may
-    // also need to split these critical edges.
-    return Changed;
-  }
-
-  // Okay, we can eliminate this load by inserting a reload in the predecessor
-  // and using PHI construction to get the value in the other predecessors, do
-  // it.
-  DEBUG(dbgs() << "GVN REMOVING PRE INSTRUCTION: " << *I << '\n');
-  DEBUG(if (!NewInsts.empty()) dbgs() << "INSERTED " << NewInsts.size()
-                                      << " INSTS: " << *NewInsts.back()
-                                      << '\n');
-
-  // Assign value numbers to the new instructions.
-  for (unsigned i = 0, e = NewInsts.size(); i != e; ++i) {
-    valueNumberNewInstruction(NewInsts[i]);
-  }
-
-  for (auto &UnavailInfo : UnavailableBlocks)
-    if (!UnavailInfo.second)
-      return false;
-
-  for (auto &UnavailInfo : UnavailableBlocks) {
-    BasicBlock *UnavailablePred = UnavailInfo.first;
-
-    Value *NewVal = regenerateExpression(UnavailInfo.second, UnavailablePred);
-    valueNumberNewInstruction(NewVal);
-    if (Instruction *NewInst = dyn_cast<Instruction>(NewVal)) {
-      NewInst->setDebugLoc(I->getDebugLoc());
-      LoadInst *LI = dyn_cast<LoadInst>(I);
-      LoadInst *NewLoadInst = dyn_cast<LoadInst>(NewInst);
-      // Transfer load tags
-      if (LI && NewLoadInst) {
-        AAMDNodes Tags;
-        LI->getAAMetadata(Tags);
-        if (Tags)
-          NewLoadInst->setAAMetadata(Tags);
-        if (MD)
-          MD->invalidateCachedPointerInfo(NewLoadInst->getPointerOperand());
-      }
-    }
-
-    // Add the newly created load.
-    ValuesPerBlock.push_back(
-        AvailableValueInBlock::get(UnavailablePred, NewVal));
-    DEBUG(dbgs() << "GVN INSERTED " << *NewVal << '\n');
-  }
-
-  // Perform PHI construction.
-  Value *V = constructSSAForSet(I, ValuesPerBlock);
-  I->replaceAllUsesWith(V);
-  PREValueForwarding[I] = V;
-  // Value of V is the same as the value of the old instruction (or it would not
-  // be redundant)
-  valueNumberNewInstructionToValue(V, I);
-
-  ValueToExpression[I] = ValueToExpression[V];
-  // I no longer exists
-  ValueToClass.lookup(I)->Members.erase(I);
-  if (isa<PHINode>(V))
-    V->takeName(I);
-  if (MD && V->getType()->getScalarType()->isPointerTy())
-    MD->invalidateCachedPointerInfo(V);
-  markInstructionForDeletion(I);
-  ++NumPRELoad;
-  return true;
-}
-
-void NewGVN::analyzeAvailability(Instruction *I,
-                                 AvailValInBlkVect &ValuesPerBlock,
-                                 UnavailBlkVect &UnavailableBlocks) {
-  for (auto P : PredCache.get(I->getParent())) {
-    if (!ReachableBlocks.count(P)) {
-      ValuesPerBlock.push_back(AvailableValueInBlock::getUndef(P));
-      continue;
-    }
-    const Expression *Before = ValueToExpression.lookup(I);
-    // This can happen if it was too complex or complicated an expression for
-    // GVN to analyze
-    if (!Before)
-      return;
-    const Expression *E = phiTranslateExpression(Before, I->getParent(), P, I);
-    Value *V = nullptr;
-    if (E) {
-      E = trySimplifyPREExpression(E, P);
-      DEBUG(dbgs() << "After simplification, expression is " << *E << "\n");
-
-      V = findPRELeader(E, P, I);
-      // If we got a store, we can rip out the source value.
-      // Otherwise, void type stuff is not acceptable
-      if (V && V->getType()->isVoidTy()) {
-        if (StoreInst *SI = dyn_cast<StoreInst>(V))
-          V = SI->getValueOperand();
-        else
-          V = nullptr;
-      }
-    }
-
-    if (!V)
-      UnavailableBlocks.push_back({P, E});
-    else
-      ValuesPerBlock.push_back(AvailableValueInBlock::get(P, V));
-  }
-}
-
-bool NewGVN::performPREOnClass(CongruenceClass *CC) {
-
-  // FIXME: Only do some
-  bool Changed = false;
-  AvailValInBlkVect ValuesPerBlock;
-
-  for (auto M : CC->Members) {
-    if (isa<PHINode>(M) || M->getType()->isVoidTy())
-      continue;
-    if (!isa<GetElementPtrInst>(M) && !isa<LoadInst>(M))
-      continue;
-
-    if (Instruction *I = dyn_cast<Instruction>(M)) {
-      UnavailBlkVect UnavailableBlocks;
-      BasicBlock *IBlock = I->getParent();
-      if (PredCache.size(IBlock) == 0)
-        continue;
-      analyzeAvailability(I, ValuesPerBlock, UnavailableBlocks);
-
-      if ((UnavailableBlocks.size() + ValuesPerBlock.size()) !=
-          PredCache.size(IBlock))
-        continue;
-#if 1
-      // If we have no predecessors that produce a known value for this load,
-      // exit early.
-      if (ValuesPerBlock.empty())
-        continue;
-#endif
-      // Step 3: Eliminate fully redundancy.
-      //
-      // If all of the instructions we depend on produce a known value for this
-      // load, then it is fully redundant and we can use PHI insertion to
-      // compute
-      // its value.  Insert PHIs and remove the fully redundant value now.
-      if (UnavailableBlocks.empty()) {
-        DEBUG(dbgs() << "GVN REMOVING INSTRUCTION: " << *I << '\n');
-
-        // Perform PHI construction.
-        Value *V = constructSSAForSet(I, ValuesPerBlock);
-        I->replaceAllUsesWith(V);
-        PREValueForwarding[I] = V;
-        valueNumberNewInstruction(V);
-        ValueToClass.lookup(I)->Members.erase(I);
-        ValueToExpression[I] = ValueToExpression[V];
-        if (isa<PHINode>(V))
-          V->takeName(I);
-        if (MD && V->getType()->getScalarType()->isPointerTy())
-          MD->invalidateCachedPointerInfo(V);
-        markInstructionForDeletion(I);
-        ++NumNewGVNPRE;
-        Changed = true;
-        continue;
-      }
-      // Step 4: Eliminate partial redundancy.
-      if (!EnablePRE || !EnableLoadPRE)
-        continue;
-      Changed |= performPRE(I, ValuesPerBlock, UnavailableBlocks);
-    }
-  }
-  return Changed;
-}
-
-// Find a leader for OP in BB.
-Value *NewGVN::findPRELeader(Value *Op, const BasicBlock *BB,
-                             const Value *MustDominate) {
-  if (alwaysAvailable(Op))
-    return Op;
-
-  CongruenceClass *CC = ValueToClass[Op];
-  if (!CC || CC == InitialClass)
-    return 0;
-
-  if (CC->RepLeader && alwaysAvailable(CC->RepLeader))
-    return CC->RepLeader;
-  for (auto M : CC->Members) {
-    if (M == MustDominate)
-      continue;
-    if (Instruction *I = dyn_cast<Instruction>(M))
-      if (DT->dominates(I->getParent(), BB))
-        return I;
-  }
-  return 0;
-}
-
-// Find a leader for OP in BB.
-Value *NewGVN::findPRELeader(const Expression *E, const BasicBlock *BB,
-                             const Value *MustDominate) {
-  if (const ConstantExpression *CE = dyn_cast<ConstantExpression>(E))
-    return CE->getConstantValue();
-  else if (const VariableExpression *VE = dyn_cast<VariableExpression>(E))
-    return findPRELeader(VE->getVariableValue(), BB, MustDominate);
-
-  DEBUG(dbgs() << "Hash value was " << E->getHashValue() << "\n");
-
-  const auto Result = ExpressionToClass.find(E);
-  if (Result == ExpressionToClass.end())
-    return 0;
-
-  CongruenceClass *CC = Result->second;
-
-  if (!CC || CC == InitialClass)
-    return 0;
-
-  if (CC->RepLeader &&
-      (isa<Argument>(CC->RepLeader) || isa<Constant>(CC->RepLeader) ||
-       isa<GlobalValue>(CC->RepLeader)))
-    return CC->RepLeader;
-
-  for (auto M : CC->Members) {
-    if (M == MustDominate)
-      continue;
-    if (Instruction *I = dyn_cast<Instruction>(M))
-      if (DT->dominates(I->getParent(), BB))
-        return I;
-  }
-  return 0;
-}
-
-MemoryAccess *NewGVN::phiTranslateMemoryAccess(MemoryAccess *MA,
-                                               const BasicBlock *Pred) {
-  if (MemoryPhi *MP = dyn_cast<MemoryPhi>(MA)) {
-    for (const auto &A : MP->operands()) {
-      if (MP->getIncomingBlock(A) == Pred) {
-        return cast<MemoryAccess>(A);
-      }
-    }
-    // We should have found something
-    return nullptr;
-  }
-  return MA;
-}
-
-static Value *phiTranslateValue(Value *Incoming, const BasicBlock *Pred) {
-  // Back translate if defined by a phi in this block
-  PHINode *P = dyn_cast<PHINode>(Incoming);
-  int Index = P->getBasicBlockIndex(Pred);
-  if (Index != -1) {
-    return P->getIncomingValue(Index);
-  }
-  // Not defined by a phi in this block
-  return Incoming;
-}
-
-bool NewGVN::phiTranslateArguments(const BasicExpression *From,
-                                   BasicExpression *To, const BasicBlock *Pred,
-                                   const Value *MustDominate) {
-  for (unsigned i = 0, e = From->getNumOperands(); i != e; ++i) {
-    Value *Arg = From->getOperand(i);
-    Value *Forwarded = PREValueForwarding.lookup(Arg);
-    if (Forwarded)
-      Arg = Forwarded;
-    // Fold in immediate adds
-    bool processedAdd = false;
-    if (Instruction *I = dyn_cast<Instruction>(Arg)) {
-      if (I->getOpcode() == Instruction::Add &&
-          isa<PHINode>(I->getOperand(0)) &&
-          isa<ConstantInt>(I->getOperand(1))) {
-
-        Constant *RHS = cast<ConstantInt>(I->getOperand(1));
-        bool isNSW = cast<BinaryOperator>(I)->hasNoSignedWrap();
-        bool isNUW = cast<BinaryOperator>(I)->hasNoUnsignedWrap();
-        Value *LHS = phiTranslateValue(I->getOperand(0), Pred);
-        // If the PHI translated LHS is an add of a constant, fold the
-        // immediates.
-        if (BinaryOperator *BOp = dyn_cast<BinaryOperator>(LHS))
-          if (BOp->getOpcode() == Instruction::Add)
-            if (ConstantInt *CI = dyn_cast<ConstantInt>(BOp->getOperand(1))) {
-              LHS = BOp->getOperand(0);
-              RHS = ConstantExpr::getAdd(RHS, CI);
-              isNSW = isNUW = false;
-            }
-        // FIXME: Handle NSW
-        const Expression *BinExpr = createBinaryExpression(
-            I->getOpcode(), I->getType(), LHS, RHS, Pred);
-        Value *Leader = findPRELeader(BinExpr, Pred, MustDominate);
-        if (Leader) {
-          Arg = Leader;
-          processedAdd = true;
-        }
-      }
-    }
-    // If arg is still a phi node, and wasn't processed by the add processing
-    // above, translate it now
-    if (!processedAdd && isa<PHINode>(Arg))
-      Arg = phiTranslateValue(Arg, Pred);
-
-    Value *Leader = findPRELeader(Arg, Pred, MustDominate);
-    if (Leader == nullptr)
-      return false;
-    To->setOperand(i, Leader);
-  }
-  return true;
-}
-const Expression *NewGVN::phiTranslateExpression(const Expression *E,
-                                                 BasicBlock *Curr,
-                                                 BasicBlock *Pred,
-                                                 const Value *MustDominate) {
-  const Expression *ResultExpr = nullptr;
-  if (const LoadExpression *LE = dyn_cast<LoadExpression>(E)) {
-
-    MemoryAccess *MA = phiTranslateMemoryAccess(LE->getDefiningAccess(), Pred);
-    if (!MA)
-      return nullptr;
-    LoadExpression *NLE = createLoadExpression(LE->getType(), LE->getOperand(0),
-                                               LE->getLoadInst(), MA, Pred);
-    if (!phiTranslateArguments(LE, NLE, Pred, MustDominate))
-      return nullptr;
-    LoadInst *LI = LE->getLoadInst();
-    MemoryLocation Loc;
-    if (LI) {
-      Loc = MemoryLocation::get(LI);
-      Loc = Loc.getWithNewPtr(NLE->getOperand(0));
-    } else {
-      Loc.Ptr = NLE->getOperand(0);
-    }
-    MA = MSSAWalker->getClobberingMemoryAccess(MA, Loc);
-    NLE->setDefiningAccess(MA);
-    ResultExpr = NLE;
-  } else if (const BasicExpression *BE = dyn_cast<BasicExpression>(E)) {
-    BasicExpression *NBE =
-        new (ExpressionAllocator) BasicExpression(BE->getNumOperands());
-    NBE->setType(BE->getType());
-    NBE->setOpcode(BE->getOpcode());
-    NBE->allocateOperands(ArgRecycler, ExpressionAllocator);
-    for (unsigned i = 0, e = BE->getNumOperands(); i != e; ++i)
-      NBE->ops_push_back(nullptr);
-    if (!phiTranslateArguments(BE, NBE, Pred, MustDominate))
-      return nullptr;
-    ResultExpr = NBE;
-  }
-
-  return ResultExpr;
-}
-
-const Expression *NewGVN::trySimplifyPREExpression(const Expression *E,
-                                                   const BasicBlock *B) {
-  const Expression *ResultExpr = E;
-  // This must come first, because LoadExpression's are BasicExpressions
-  if (const LoadExpression *LE = dyn_cast<LoadExpression>(E)) {
-    MemoryDef *MD = dyn_cast<MemoryDef>(LE->getDefiningAccess());
-    if (MD && !MSSA->isLiveOnEntryDef(MD)) {
-      const Expression *Temp = performSymbolicLoadCoercion(
-          LE->getType(), LE->getOperand(0), LE->getLoadInst(),
-          MD->getMemoryInst(), MD, B);
-      if (Temp)
-        ResultExpr = Temp;
-    }
-  } else if (const BasicExpression *BE = dyn_cast<BasicExpression>(E)) {
-    unsigned Opcode = BE->getOpcode();
-    if (Instruction::isBinaryOp(Opcode)) {
-      Value *V = SimplifyBinOp(Opcode, BE->getOperand(0), BE->getOperand(1),
-                               *DL, TLI, DT, AC);
-      if (V) {
-        if (Constant *C = dyn_cast<Constant>(V))
-          ResultExpr = createConstantExpression(C, false);
-        else if (alwaysAvailable(V))
-          ResultExpr = createVariableExpression(V, false);
-      }
-    } else if (Opcode == Instruction::GetElementPtr) {
-      Value *V = SimplifyGEPInst(BE->getType(),
-                                 makeArrayRef(BE->ops_begin(), BE->ops_end()),
-                                 *DL, TLI, DT, AC);
-      if (V) {
-        if (Constant *C = dyn_cast<Constant>(V))
-          ResultExpr = createConstantExpression(C, false);
-        else if (alwaysAvailable(V))
-          ResultExpr = createVariableExpression(V, false);
-      }
-    }
-  }
-  return ResultExpr;
-}
